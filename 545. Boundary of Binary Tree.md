# 545. Boundary of Binary Tree

## Problem Link
[LeetCode Problem #545](https://leetcode.com/problems/boundary-of-binary-tree/)

## Problem Statement
The **boundary** of a binary tree is the concatenation of the **root**, the **left boundary**, the **leaves** ordered from left-to-right, and the **reverse order** of the **right boundary**.

**Definitions:**
- **Left Boundary:** The path from root to the **left-most** node (excluding leaf nodes). If root has no left subtree, the left boundary is empty.
- **Right Boundary:** The path from root to the **right-most** node (excluding leaf nodes). If root has no right subtree, the right boundary is empty.
- **Leaves:** All leaf nodes ordered from left-to-right.
- **Left-most node:** The node you reach by always going left; if no left child exists, go right. Repeat until reaching a leaf.
- **Right-most node:** The node you reach by always going right; if no right child exists, go left. Repeat until reaching a leaf.

**Note:** Nodes may not be repeated in the output. The root only appears once.

**Example 1:**
```
Input: root = [1,null,2,3,4]

    1
     \
      2
     / \
    3   4

Output: [1,3,4,2]
Explanation:
- Root: [1]
- Left boundary: [] (no left subtree)
- Leaves: [3,4]
- Right boundary reversed: [2]
Result: [1] + [] + [3,4] + [2] = [1,3,4,2]
```

**Example 2:**
```
Input: root = [1,2,3,4,5,6,null,null,null,7,8,9,10]

        1
       / \
      2   3
     / \   \
    4   5   6
       / \
      7   8

Output: [1,2,4,7,8,9,10,6,3]
```

**Constraints:**
- The number of nodes in the tree is in the range [1, 10^4]
- -1000 <= Node.val <= 1000

---

## Intuition

Imagine **walking around the perimeter** of a tree like tracing its outline on paper:

1. Start at the **root** (top)
2. Walk down the **left edge** (going left when possible)
3. Walk along the **bottom** (all leaves, left to right)
4. Walk up the **right edge** (going right when possible)

```
        1  â† Start here
       / \
      2   3
     / \   \
    4   5   6
       / \
      7   8

Trace: 1 â†’ 2 â†’ 4 â†’ 7 â†’ 8 â†’ 5 â†’ 6 â†’ 3 â†’ back to top
Result: [1, 2, 4, 7, 8, 5, 6, 3]
```

**Key insight:** This is like drawing the tree's **outline clockwise**, starting from the root!

---

## Core Idea & Thinking

The problem naturally decomposes into **three independent parts**:

### 1. **Left Boundary (Top â†’ Bottom)**
- Travel down the left edge
- Prefer left child; if no left child, use right child
- Add nodes **before** recursing (pre-order)
- Skip leaf nodes (they'll be added in the leaves section)

### 2. **All Leaves (Left â†’ Right)**
- Do any traversal (preorder/inorder work well)
- Add only leaf nodes
- Traverse left subtree before right subtree to maintain order

### 3. **Right Boundary (Bottom â†’ Top)**
- Travel down the right edge
- Prefer right child; if no right child, use left child
- Add nodes **after** recursing (post-order) to reverse the order
- Skip leaf nodes

**Critical Observations:**
- Boundaries exclude leaves (to avoid duplicates)
- Left boundary: pre-order traversal (add then recurse)
- Right boundary: post-order traversal (recurse then add) for reverse order
- Root is added only once, even if it's on a boundary

---

## Visual Walkthrough

### Example Tree:
```
        1
       / \
      2   3
     / \   \
    4   5   6
       / \
      7   8
```

### Step-by-Step Construction:

#### **Phase 1: Add Root**
```
Check: isLeaf(1)? No (has children)
Action: Add 1

Result: [1]
```

#### **Phase 2: Add Left Boundary**
```
Path from 1 â†’ leftmost (prefer left child):

Node 2:
  - isLeaf(2)? No (has children 4, 5)
  - Add 2 (before recursion - pre-order)
  - Has left child? Yes â†’ recurse on 4
  
Node 4:
  - isLeaf(4)? Yes (no children)
  - Skip (leaves added later)
  - Stop

Result: [1, 2]
```

#### **Phase 3: Add All Leaves (Left to Right)**
```
Traverse entire tree, collect leaves:

DFS path: 1 â†’ 2 â†’ 4 â†’ 5 â†’ 7 â†’ 8 â†’ 3 â†’ 6

Leaves found:
  - Node 4: isLeaf? Yes â†’ add 4
  - Node 7: isLeaf? Yes â†’ add 7
  - Node 8: isLeaf? Yes â†’ add 8
  - Node 5: has no more children, but wait...
    Actually 5 is NOT a leaf (has 7, 8)
  - Node 6: isLeaf? Yes â†’ add 6

Result: [1, 2, 4, 7, 8, 6]
```

Wait, let me recalculate the leaves correctly:

```
Traverse tree for leaves:
  - 1: not a leaf
    - 2: not a leaf
      - 4: IS A LEAF â†’ add 4
      - 5: not a leaf (has 7, 8)
        - 7: IS A LEAF â†’ add 7
        - 8: IS A LEAF â†’ add 8
    - 3: not a leaf
      - 6: IS A LEAF â†’ add 6

Result: [1, 2, 4, 7, 8, 6]
```

#### **Phase 4: Add Right Boundary (Bottom to Top)**
```
Path from 1 â†’ rightmost (prefer right child):

Start at node 3:
  - Has right child? Yes (6) â†’ recurse on 6
  
  Node 6:
    - isLeaf(6)? Yes
    - Skip (already added in leaves)
    - Return to 3
  
  Back at node 3:
    - isLeaf(3)? No (has child 6)
    - Add 3 (after recursion - post-order)

Result: [1, 2, 4, 7, 8, 6, 3]
```

**Final Answer:** `[1, 2, 4, 7, 8, 6, 3]`

---

## Detailed Algorithm Flow

Let's trace through the corrected example: `[1,2,3,4,5,6,null,null,null,7,8]`

```
        1
       / \
      2   3
     / \   \
    4   5   6
       / \
      7   8
```

### Execution Trace:

```java
boundaryOfBinaryTree(root=1):
  1. if (!isLeaf(1)) list.add(1.val)    â†’ [1]
  2. addLeft(2, list)
  3. addLeaves(1, list)
  4. addRight(3, list)
```

---

### **Step 2: addLeft(node=2, list=[1])**

```java
addLeft(2, list):
  - node == null? No
  - isLeaf(2)? No (has 4 and 5)
  - list.add(2)                         â†’ [1, 2]
  - node.left != null? Yes (4 exists)
  - addLeft(4, list)
  
    addLeft(4, list):
      - node == null? No
      - isLeaf(4)? Yes (no children)
      - Don't add (skip leaves)
      - node.left != null? No
      - addLeft(null, list) â†’ returns immediately
```

**After addLeft:** `[1, 2]`

---

### **Step 3: addLeaves(node=1, list=[1,2])**

```java
addLeaves(1, list):
  - node == null? No
  - isLeaf(1)? No
  - addLeaves(1.left=2, list)
    
    addLeaves(2, list):
      - isLeaf(2)? No
      - addLeaves(2.left=4, list)
        
        addLeaves(4, list):
          - isLeaf(4)? Yes
          - list.add(4)                 â†’ [1, 2, 4]
          - return
      
      - addLeaves(2.right=5, list)
        
        addLeaves(5, list):
          - isLeaf(5)? No (has 7, 8)
          - addLeaves(5.left=7, list)
            
            addLeaves(7, list):
              - isLeaf(7)? Yes
              - list.add(7)             â†’ [1, 2, 4, 7]
              - return
          
          - addLeaves(5.right=8, list)
            
            addLeaves(8, list):
              - isLeaf(8)? Yes
              - list.add(8)             â†’ [1, 2, 4, 7, 8]
              - return
  
  - addLeaves(1.right=3, list)
    
    addLeaves(3, list):
      - isLeaf(3)? No
      - addLeaves(3.left=null, list) â†’ return
      - addLeaves(3.right=6, list)
        
        addLeaves(6, list):
          - isLeaf(6)? Yes
          - list.add(6)                 â†’ [1, 2, 4, 7, 8, 6]
          - return
```

**After addLeaves:** `[1, 2, 4, 7, 8, 6]`

---

### **Step 4: addRight(node=3, list=[1,2,4,7,8,6])**

```java
addRight(3, list):
  - node == null? No
  - node.right != null? Yes (6 exists)
  - addRight(6, list)
    
    addRight(6, list):
      - node == null? No
      - node.right != null? No
      - addRight(null, list) â†’ returns immediately
      - isLeaf(6)? Yes
      - Don't add (skip leaves)
  
  - Back to node 3
  - isLeaf(3)? No (has child 6)
  - list.add(3)                         â†’ [1, 2, 4, 7, 8, 6, 3]
```

**After addRight:** `[1, 2, 4, 7, 8, 6, 3]`

---

**Final Result:** `[1, 2, 4, 7, 8, 6, 3]`

---

## Solution Code (Optimized) âœ…

```java
class Solution {
    public List<Integer> boundaryOfBinaryTree(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if (root == null) {
            return list;
        }
        
        // Step 1: Add root (if it's not a leaf)
        if (!isLeaf(root)) {
            list.add(root.val);
        }
        
        // Step 2: Add left boundary (top to bottom, excluding leaves)
        addLeft(root.left, list);
        
        // Step 3: Add all leaves (left to right)
        addLeaves(root, list);
        
        // Step 4: Add right boundary (bottom to top, excluding leaves)
        addRight(root.right, list);
        
        return list;
    }
    
    // Add left boundary nodes (excluding leaves)
    private void addLeft(TreeNode node, List<Integer> list) {
        if (node == null) return;
        
        if (!isLeaf(node)) {
            list.add(node.val); // Add before recursing (top-to-bottom)
        }
        
        // Prefer left child, then right child
        if (node.left != null) {
            addLeft(node.left, list);
        } else {
            addLeft(node.right, list);
        }
    }
    
    // Add all leaf nodes (left to right)
    private void addLeaves(TreeNode node, List<Integer> list) {
        if (node == null) return;
        
        if (isLeaf(node)) {
            list.add(node.val);
            return;
        }
        
        // Traverse left then right to maintain left-to-right order
        addLeaves(node.left, list);
        addLeaves(node.right, list);
    }
    
    // Add right boundary nodes (excluding leaves) in reverse order
    private void addRight(TreeNode node, List<Integer> list) {
        if (node == null) return;
        
        // Prefer right child, then left child
        if (node.right != null) {
            addRight(node.right, list);
        } else {
            addRight(node.left, list);
        }
        
        if (!isLeaf(node)) {
            list.add(node.val); // Add after recursing (bottom-to-top)
        }
    }
    
    // Helper: check if node is a leaf
    private boolean isLeaf(TreeNode node) {
        return node.left == null && node.right == null;
    }
}
```

### Complexity Analysis
- **Time Complexity:** O(n)
  - `addLeft`: O(h) where h is height
  - `addLeaves`: O(n) visits every node once
  - `addRight`: O(h)
  - Total: O(n) since leaves dominate
  
- **Space Complexity:** O(h)
  - Recursion stack for all three functions
  - Best case (balanced tree): O(log n)
  - Worst case (skewed tree): O(n)

---

## Alternative Approach: Iterative with Stack

```java
class Solution {
    public List<Integer> boundaryOfBinaryTree(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) return result;
        
        // Add root if not leaf
        if (!isLeaf(root)) result.add(root.val);
        
        // LEFT BOUNDARY (iterative)
        TreeNode curr = root.left;
        while (curr != null) {
            if (!isLeaf(curr)) result.add(curr.val);
            curr = (curr.left != null) ? curr.left : curr.right;
        }
        
        // LEAVES (can remain recursive or use iterative traversal)
        addLeavesHelper(root, result);
        
        // RIGHT BOUNDARY (use stack for reverse)
        Stack<Integer> stack = new Stack<>();
        curr = root.right;
        while (curr != null) {
            if (!isLeaf(curr)) stack.push(curr.val);
            curr = (curr.right != null) ? curr.right : curr.left;
        }
        
        // Add right boundary in reverse
        while (!stack.isEmpty()) {
            result.add(stack.pop());
        }
        
        return result;
    }
    
    private void addLeavesHelper(TreeNode node, List<Integer> result) {
        if (node == null) return;
        if (isLeaf(node)) {
            result.add(node.val);
            return;
        }
        addLeavesHelper(node.left, result);
        addLeavesHelper(node.right, result);
    }
    
    private boolean isLeaf(TreeNode node) {
        return node != null && node.left == null && node.right == null;
    }
}
```

### Complexity Analysis
- **Time Complexity:** O(n)
- **Space Complexity:** O(h) for stack in worst case

---

## Brute Force Approach (Not Recommended)

### Idea
Store all nodes with their positions, then filter and sort.

```java
class BruteForceSolution {
    public List<Integer> boundaryOfBinaryTree(TreeNode root) {
        Set<TreeNode> boundaryNodes = new HashSet<>();
        List<Integer> result = new ArrayList<>();
        
        if (root == null) return result;
        
        // Add root
        result.add(root.val);
        if (isLeaf(root)) return result;
        
        // Collect left boundary
        TreeNode curr = root.left;
        while (curr != null) {
            if (!isLeaf(curr)) {
                boundaryNodes.add(curr);
                result.add(curr.val);
            }
            curr = (curr.left != null) ? curr.left : curr.right;
        }
        
        // Collect all leaves
        List<TreeNode> leaves = new ArrayList<>();
        collectLeaves(root, leaves);
        for (TreeNode leaf : leaves) {
            if (!boundaryNodes.contains(leaf)) {
                result.add(leaf.val);
            }
        }
        
        // Collect right boundary
        List<Integer> rightBoundary = new ArrayList<>();
        curr = root.right;
        while (curr != null) {
            if (!isLeaf(curr)) {
                rightBoundary.add(curr.val);
            }
            curr = (curr.right != null) ? curr.right : curr.left;
        }
        Collections.reverse(rightBoundary);
        result.addAll(rightBoundary);
        
        return result;
    }
    
    private void collectLeaves(TreeNode node, List<TreeNode> leaves) {
        if (node == null) return;
        if (isLeaf(node)) leaves.add(node);
        collectLeaves(node.left, leaves);
        collectLeaves(node.right, leaves);
    }
    
    private boolean isLeaf(TreeNode node) {
        return node.left == null && node.right == null;
    }
}
```

**Drawbacks:** More complex, uses extra space for tracking, harder to understand.

---

## Key Insights & Patterns

### ğŸ¯ Pre-order vs Post-order

The magic is in **when** you add nodes:

```java
// LEFT BOUNDARY - Pre-order (add BEFORE recurse)
private void addLeft(TreeNode node, List<Integer> list) {
    if (node == null) return;
    
    if (!isLeaf(node)) {
        list.add(node.val);  // â† Add FIRST (top-to-bottom)
    }
    
    if (node.left != null) addLeft(node.left, list);
    else addLeft(node.right, list);
}

// RIGHT BOUNDARY - Post-order (add AFTER recurse)
private void addRight(TreeNode node, List<Integer> list) {
    if (node == null) return;
    
    if (node.right != null) addRight(node.right, list);
    else addRight(node.left, list);
    
    if (!isLeaf(node)) {
        list.add(node.val);  // â† Add LAST (bottom-to-top)
    }
}
```

**Why this works:**
- **Pre-order:** Process root before children â†’ top-to-bottom
- **Post-order:** Process children before root â†’ bottom-to-top (natural reverse!)

---

### ğŸ¯ The isLeaf() Guard

```java
if (!isLeaf(node)) {
    list.add(node.val);
}
```

This critical check:
- âœ… Prevents duplicate leaf nodes in boundaries
- âœ… Ensures leaves only appear in the leaves section
- âœ… Keeps the boundary "edges only" (no corners/leaves)

---

### ğŸ¯ Preference Logic

```java
// Left boundary: prefer LEFT child
if (node.left != null) {
    addLeft(node.left, list);
} else {
    addLeft(node.right, list);  // Fallback to right
}

// Right boundary: prefer RIGHT child
if (node.right != null) {
    addRight(node.right, list);
} else {
    addRight(node.left, list);  // Fallback to left
}
```

This ensures we follow the **outermost path** on each side.

---

## Common Mistakes to Avoid

### âŒ Mistake 1: Adding Leaves to Boundaries
```java
// WRONG - includes leaves in boundary
list.add(node.val);
```

âœ… **Correct:**
```java
if (!isLeaf(node)) {
    list.add(node.val);
}
```

---

### âŒ Mistake 2: Wrong Order for Right Boundary
```java
// WRONG - gives top-to-bottom (not reversed)
if (!isLeaf(node)) list.add(node.val);
addRight(node.right, list);
```

âœ… **Correct:** Recurse first, then add
```java
addRight(node.right, list);
if (!isLeaf(node)) list.add(node.val);
```

---

### âŒ Mistake 3: Including Root Multiple Times
```java
// WRONG - root might be added twice
list.add(root.val);
addLeft(root, list);
```

âœ… **Correct:** Check if root is leaf, start boundaries from children
```java
if (!isLeaf(root)) list.add(root.val);
addLeft(root.left, list);
```

---

### âŒ Mistake 4: Wrong Condition in addLeaves
```java
// WRONG - adds non-leaves
if (!isLeaf(node)) {
    list.add(node.val);
}
```

âœ… **Correct:**
```java
if (isLeaf(node)) {
    list.add(node.val);
    return;
}
```

---

## Visualization with Direction Arrows

```
        1  â† Start
       â†™ â†˜
      2   3
     â†™ â†˜   â†˜
    4   5   6
       â†™ â†˜
      7   8

Path Trace (clockwise):
1 â†’ 2 â†’ 4 â†’ 7 â†’ 8 â†’ 6 â†’ 3 â†’ (back to 1)

Components:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Root:          [1]                   â”‚
â”‚ Left Boundary: [2]                   â”‚
â”‚ Leaves:        [4, 7, 8, 6]          â”‚
â”‚ Right Boundary:[3] (reversed order)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Final: [1, 2, 4, 7, 8, 6, 3]
```

---

## Related Problems

- **102. Binary Tree Level Order Traversal**
- **199. Binary Tree Right Side View**
- **314. Binary Tree Vertical Order Traversal**
- **987. Vertical Order Traversal of a Binary Tree**
- **144. Binary Tree Preorder Traversal**
- **145. Binary Tree Postorder Traversal**

---

## Summary

**Boundary Traversal** is about decomposing a complex problem into three simpler parts:

| Component | Direction | Traversal Type | Key Rule |
|-----------|-----------|----------------|----------|
| **Left Boundary** | Top â†’ Bottom | Pre-order | Exclude leaves |
| **Leaves** | Left â†’ Right | Any order | Include all |
| **Right Boundary** | Bottom â†’ Top | Post-order | Exclude leaves |

**Key Techniques:**
1. Use `isLeaf()` to prevent duplicates
2. Pre-order for left boundary (add before recurse)
3. Post-order for right boundary (add after recurse)
4. Prefer appropriate child at each step

**Time:** O(n) | **Space:** O(h)

This problem teaches important concepts about tree traversal orders, recursion timing, and problem decomposition! ğŸŒ²âœ¨
