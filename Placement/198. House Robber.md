# LeetCode 198: House Robber

**Difficulty:** Medium  
**Problem Link:** [House Robber - LeetCode](https://leetcode.com/problems/house-robber/)

---

## Problem Statement

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.

### Examples

**Example 1:**
```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

**Example 2:**
```
Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
```

---

## Intuition

The key insight is that at each house, you face a decision:
1. **Rob this house** - If you rob it, you can't rob the previous house, so you add current house money to the max money from two houses back
2. **Skip this house** - If you skip it, you keep the max money you had from the previous house

This is a classic **dynamic programming** problem where each decision depends on previous decisions.

![House Robber Visualization](https://assets.leetcode.com/users/images/ed2cc6d4-2f9e-4c1f-9b5e-3e5e5e5e5e5e_1615234567.8745446.png)

---

## Core Idea & Thinking View

### The Decision Pattern

For each house `i`, we have:
```
dp[i] = max(dp[i-1], dp[i-2] + nums[i])
```

Where:
- `dp[i]` = maximum money we can rob up to house `i`
- `dp[i-1]` = skip current house, take max from previous house
- `dp[i-2] + nums[i]` = rob current house, add to max from two houses back

### Why This Works

Since we can't rob adjacent houses:
- If we rob house `i`, we must have skipped house `i-1`
- Therefore, the best we could have done before is at house `i-2`
- If we skip house `i`, the best is whatever we had at house `i-1`

---

## Approach 1: Brute Force (Recursion)

### Algorithm
Try all possible combinations by recursively deciding whether to rob or skip each house.

### Code
```java
class Solution {
    public int rob(int[] nums) {
        return robFrom(0, nums);
    }
    
    private int robFrom(int index, int[] nums) {
        // Base case: no more houses to rob
        if (index >= nums.length) {
            return 0;
        }
        
        // Option 1: Rob current house and skip next
        int robCurrent = nums[index] + robFrom(index + 2, nums);
        
        // Option 2: Skip current house and move to next
        int skipCurrent = robFrom(index + 1, nums);
        
        // Return maximum of both options
        return Math.max(robCurrent, skipCurrent);
    }
}
```

### Complexity
- **Time:** O(2^n) - Each house has 2 choices, exponential growth
- **Space:** O(n) - Recursion call stack depth

### Why It's Inefficient
The recursion solves the same subproblems multiple times. For example, `robFrom(2)` might be calculated many times.

---

## Approach 2: Dynamic Programming (Memoization)

### Algorithm
Cache the results of subproblems to avoid redundant calculations.

### Code
```java
class Solution {
    private Integer[] memo;
    
    public int rob(int[] nums) {
        memo = new Integer[nums.length];
        return robFrom(0, nums);
    }
    
    private int robFrom(int index, int[] nums) {
        if (index >= nums.length) {
            return 0;
        }
        
        // Return cached result if available
        if (memo[index] != null) {
            return memo[index];
        }
        
        int robCurrent = nums[index] + robFrom(index + 2, nums);
        int skipCurrent = robFrom(index + 1, nums);
        
        // Cache the result
        memo[index] = Math.max(robCurrent, skipCurrent);
        return memo[index];
    }
}
```

### Complexity
- **Time:** O(n) - Each subproblem solved once
- **Space:** O(n) - Memoization array + recursion stack

---

## Approach 3: Dynamic Programming (Tabulation)

### Algorithm
Build up the solution iteratively using a DP array.

### Code
```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) return nums[0];
        
        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);
        }
        
        return dp[n-1];
    }
}
```

### Complexity
- **Time:** O(n) - Single pass through array
- **Space:** O(n) - DP array

---

## Approach 4: Optimized Space (Two Variables) ⭐

### Algorithm
Since we only need the previous two values, we can use just two variables instead of an array.

### Code
```java
class Solution {
    public int rob(int[] nums) {
        int prev1 = 0;  // dp[i-1]
        int prev2 = 0;  // dp[i-2]
        
        for (int cash : nums) {
            int curr = Math.max(prev1, prev2 + cash);
            prev2 = prev1;
            prev1 = curr;
        }
        
        return prev1;
    }
}
```

### Complexity
- **Time:** O(n) - Single pass through array
- **Space:** O(1) - Only two variables used

---

## Algorithm Flow with Example

Let's trace through `nums = [2, 7, 9, 3, 1]`

### Initial State
```
prev2 = 0
prev1 = 0
```

### Iteration 1: house = 2
```
curr = max(prev1, prev2 + 2) = max(0, 0 + 2) = 2
prev2 = 0 → prev1 = 0
prev1 = 2 → curr = 2

State: prev2=0, prev1=2
```

### Iteration 2: house = 7
```
curr = max(prev1, prev2 + 7) = max(2, 0 + 7) = 7
prev2 = 2 → prev1 = 2
prev1 = 7 → curr = 7

State: prev2=2, prev1=7
```

### Iteration 3: house = 9
```
curr = max(prev1, prev2 + 9) = max(7, 2 + 9) = 11
prev2 = 7 → prev1 = 7
prev1 = 11 → curr = 11

State: prev2=7, prev1=11
```

### Iteration 4: house = 3
```
curr = max(prev1, prev2 + 3) = max(11, 7 + 3) = 11
prev2 = 11 → prev1 = 11
prev1 = 11 → curr = 11

State: prev2=11, prev1=11
```

### Iteration 5: house = 1
```
curr = max(prev1, prev2 + 1) = max(11, 11 + 1) = 12
prev2 = 11 → prev1 = 11
prev1 = 12 → curr = 12

State: prev2=11, prev1=12
```

### Final Answer: 12

**Houses robbed:** House 0 (2) + House 2 (9) + House 4 (1) = 12

---

## Visual Representation

```
Houses:  [2,  7,  9,  3,  1]
Index:    0   1   2   3   4

DP Array (if we used tabulation):
dp[0] = 2                           (rob house 0)
dp[1] = max(2, 7) = 7              (rob house 1)
dp[2] = max(7, 2+9) = 11           (rob houses 0,2)
dp[3] = max(11, 7+3) = 11          (skip house 3)
dp[4] = max(11, 11+1) = 12         (rob house 4)

Decision Path:
House 0: Rob (2)
House 1: Skip
House 2: Rob (9)
House 3: Skip
House 4: Rob (1)
Total: 2 + 9 + 1 = 12
```

---

## Key Insights

1. **Recurrence Relation:** `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`
2. **Base Cases:** 
   - `dp[0] = nums[0]`
   - `dp[1] = max(nums[0], nums[1])`
3. **Space Optimization:** Only need last 2 values, not entire array
4. **Greedy Doesn't Work:** Can't just pick every other house - need DP to find optimal solution

---

## Common Pitfalls

1. ❌ Thinking you should always rob every other house
2. ❌ Not handling edge cases (array length 1 or 2)
3. ❌ Forgetting to update both `prev1` and `prev2` correctly

---

## Related Problems

- [LeetCode 213: House Robber II](https://leetcode.com/problems/house-robber-ii/) (houses in a circle)
- [LeetCode 337: House Robber III](https://leetcode.com/problems/house-robber-iii/) (binary tree structure)

---

## Summary

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Brute Force Recursion | O(2^n) | O(n) | Too slow |
| Memoization | O(n) | O(n) | Good for understanding |
| Tabulation | O(n) | O(n) | Clear DP pattern |
| **Space Optimized** | **O(n)** | **O(1)** | **Best solution** ✅ |

The space-optimized solution is the best approach for interviews as it demonstrates understanding of DP while achieving optimal complexity.
