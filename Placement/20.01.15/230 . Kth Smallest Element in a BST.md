# LeetCode 230: Kth Smallest Element in a BST

**Problem Link:** [https://leetcode.com/problems/kth-smallest-element-in-a-bst/](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)

**Difficulty:** Medium

---

## Problem Statement

Given the root of a binary search tree (BST) and an integer `k`, return the `kth` smallest value (1-indexed) of all the values of the nodes in the tree.

**Example 1:**
```
Input: root = [3,1,4,null,2], k = 1
Output: 1
```

**Example 2:**
```
Input: root = [5,3,6,2,4,null,null,1], k = 3
Output: 3
```

---

## Core Idea & Intuition

The key insight is leveraging the **BST property**: In a Binary Search Tree, an **inorder traversal** (left → root → right) visits nodes in **ascending sorted order**.

**Why does this work?**
- BST property: left subtree < root < right subtree
- Inorder traversal naturally processes nodes from smallest to largest
- The kth node visited during inorder traversal is the kth smallest element

**Think of it like this:** Instead of extracting all values and sorting them, we're "walking through" the tree in sorted order and stopping at the kth position.

---

## Approach 1: Brute Force (Inorder + Store All Values)

### Algorithm
1. Perform inorder traversal of the entire BST
2. Store all node values in an array/list
3. Return the element at index `k-1` (0-indexed)

### Implementation
```java
public class Solution {
    public int kthSmallest(TreeNode root, int k) {
        List<Integer> values = new ArrayList<>();
        inorder(root, values);
        return values.get(k - 1);
    }
    
    private void inorder(TreeNode node, List<Integer> values) {
        if (node == null) return;
        
        inorder(node.left, values);
        values.add(node.val);
        inorder(node.right, values);
    }
}
```

### Complexity
- **Time:** O(n) - visit all n nodes
- **Space:** O(n) - store all values in list + recursion stack

### Drawback
This approach is inefficient because it processes the entire tree even after finding the kth element.

---

## Approach 2: Optimized Inorder Traversal (Early Termination)

### Core Thinking
Instead of storing all values, we can **count nodes as we traverse** and stop immediately when we reach the kth node. This is the approach in your provided code.

### Algorithm Flow
1. Perform inorder traversal (left → root → right)
2. Maintain a counter that increments with each node visited
3. When counter equals k, store the result and return
4. No need to continue traversal after finding the answer

### Implementation (Your Code - Cleaned)
```java
public class KthSmallestElementInBST {
    int count = 0;
    int result = Integer.MIN_VALUE;

    public int kthSmallest(TreeNode root, int k) {
        inorder(root, k);
        return result;
    }

    private void inorder(TreeNode root, int k) {
        if (root == null) {
            return;
        }

        // Traverse left subtree (smaller values)
        inorder(root.left, k);
        
        // Process current node
        count++;
        if (count == k) {
            result = root.val;
            return; // Early termination
        }

        // Traverse right subtree (larger values)
        inorder(root.right, k);
    }
}
```

### Complexity
- **Time:** O(H + k) where H is tree height
  - Best case (balanced): O(log n + k)
  - Worst case (skewed): O(n)
  - In practice, stops after visiting k nodes
- **Space:** O(H) for recursion stack
  - Best: O(log n)
  - Worst: O(n)

---

## Example Walkthrough

Let's trace through **Example 2** with the optimized approach:

```
Tree structure:        k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
```

**Inorder Traversal Steps:**

| Step | Node Visited | Count | Action |
|------|--------------|-------|--------|
| 1 | 1 | 1 | count != k, continue |
| 2 | 2 | 2 | count != k, continue |
| 3 | 3 | 3 | count == k, **result = 3, STOP** |

**Path taken:** 5 → 3 → 2 → 1 (visit) → backtrack → 2 (visit) → backtrack → 3 (visit, **found!**)

We never visit nodes 4, 5, or 6 because we found the answer early!

### Visual Representation

```
Inorder sequence: 1, 2, 3, 4, 5, 6
Positions:        1  2  3  4  5  6
                        ↑
                      k=3 (answer: 3)
```

---

## Approach 3: Iterative Inorder (Alternative)

For those who prefer iterative solutions:

```java
public int kthSmallest(TreeNode root, int k) {
    Stack<TreeNode> stack = new Stack<>();
    TreeNode current = root;
    int count = 0;
    
    while (current != null || !stack.isEmpty()) {
        // Go to leftmost node
        while (current != null) {
            stack.push(current);
            current = current.left;
        }
        
        // Process node
        current = stack.pop();
        count++;
        if (count == k) {
            return current.val;
        }
        
        // Move to right subtree
        current = current.right;
    }
    
    return -1; // Should never reach here if k is valid
}
```

---

## Key Takeaways

1. **BST + Inorder = Sorted Order** - This is the fundamental insight
2. **Early Termination** - Don't process more nodes than necessary
3. **Counter-based tracking** - More efficient than storing all values
4. **Space-time tradeoff** - Recursive uses O(H) space but is cleaner; iterative uses O(H) for stack but gives more control

---

## Common Pitfalls

1. Forgetting that k is 1-indexed (not 0-indexed)
2. Not handling the case where k > number of nodes
3. Continuing traversal after finding the kth element
4. Using instance variables without resetting them (if solving multiple test cases)

---

## Follow-up Question

**What if the BST is modified frequently (insertions/deletions) and you need to find the kth smallest element often?**

**Answer:** Augment each node with a count of nodes in its left subtree. This allows O(H) lookup without traversal, at the cost of O(H) updates per insertion/deletion.
