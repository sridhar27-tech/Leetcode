# LeetCode 108: Convert Sorted Array to Binary Search Tree

## Problem Link
[Convert Sorted Array to Binary Search Tree - LeetCode](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)

## Problem Statement
Given an integer array `nums` where the elements are sorted in **ascending order**, convert it to a **height-balanced** binary search tree.

A **height-balanced** binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.

### Example 1:
```
Input: nums = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: [0,-10,5,null,-3,null,9] is also accepted
```

### Example 2:
```
Input: nums = [1,3]
Output: [3,1]
Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.
```

### Constraints:
- `1 <= nums.length <= 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` is sorted in **strictly increasing** order

---

## Intuition

The key insight is that a sorted array is essentially an **inorder traversal** of a BST. To build a height-balanced BST, we need to ensure that the tree is as balanced as possible.

The middle element of the sorted array should be the root to ensure balance. The left half of the array forms the left subtree, and the right half forms the right subtree. This recursive division ensures the tree remains balanced.

---

## Core Idea & Thinking Process

### Why middle element as root?
1. In a balanced BST, the root should have approximately equal nodes in left and right subtrees
2. Since the array is sorted, picking the middle element ensures:
   - All elements to the left are smaller (left subtree)
   - All elements to the right are larger (right subtree)
   - Equal distribution of nodes on both sides

### Recursive Pattern:
- **Base case**: When left > right, return null (no more elements)
- **Recursive case**: 
  - Find middle element → make it root
  - Recursively build left subtree from left half
  - Recursively build right subtree from right half

---

## Approach 1: Brute Force (Not Applicable)

For this problem, there isn't really a "brute force" approach that differs significantly from the optimal solution. You could theoretically:
- Insert elements one by one into a BST
- Use self-balancing operations (like AVL rotations)

However, this would be:
- **Time Complexity**: O(n log n) - each insertion takes O(log n) in balanced case
- **Space Complexity**: O(n) for the tree + O(log n) for recursion
- More complex and inefficient than the direct construction approach

---

## Approach 2: Optimized Solution (Divide and Conquer)

### Algorithm
1. Use a helper function with left and right pointers
2. Find the middle index: `mid = left + (right - left) / 2`
3. Create a node with the middle element
4. Recursively build left subtree from [left, mid-1]
5. Recursively build right subtree from [mid+1, right]
6. Return the node

### Java Implementation
```java
public class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return buildBST(nums, 0, nums.length - 1);
    }

    private TreeNode buildBST(int[] nums, int left, int right) {
        // Base case: no elements in this range
        if (left > right) {
            return null;
        }

        // Choose middle element as root for balance
        int mid = left + (right - left) / 2;
        TreeNode node = new TreeNode(nums[mid]);
        
        // Recursively build left and right subtrees
        node.left = buildBST(nums, left, mid - 1);
        node.right = buildBST(nums, mid + 1, right);

        return node;
    }
}
```

### Time Complexity: O(n)
- We visit each element exactly once to create a node
- n elements → n recursive calls

### Space Complexity: O(log n)
- Recursion stack depth in a balanced tree
- O(log n) for a height-balanced tree
- O(n) in worst case if we count the output tree itself

---

## Flow of Algorithm with Example

Let's trace through `nums = [-10, -3, 0, 5, 9]`:

### Step-by-Step Execution:

```
Initial Call: buildBST(nums, 0, 4)
├── mid = 0 + (4-0)/2 = 2
├── Create node with nums[2] = 0
├── Build left subtree: buildBST(nums, 0, 1)
│   ├── mid = 0 + (1-0)/2 = 0
│   ├── Create node with nums[0] = -10
│   ├── Build left: buildBST(nums, 0, -1) → null
│   └── Build right: buildBST(nums, 1, 1)
│       ├── mid = 1
│       ├── Create node with nums[1] = -3
│       ├── Build left: buildBST(nums, 1, 0) → null
│       └── Build right: buildBST(nums, 2, 1) → null
│       └── Return node(-3)
│   └── Return node(-10) with right=-3
└── Build right subtree: buildBST(nums, 3, 4)
    ├── mid = 3 + (4-3)/2 = 3
    ├── Create node with nums[3] = 5
    ├── Build left: buildBST(nums, 3, 2) → null
    └── Build right: buildBST(nums, 4, 4)
        ├── mid = 4
        ├── Create node with nums[4] = 9
        ├── Build left: buildBST(nums, 4, 3) → null
        └── Build right: buildBST(nums, 5, 4) → null
        └── Return node(9)
    └── Return node(5) with right=9
└── Return node(0) with left=(-10→-3) and right=(5→9)
```

### Visual Representation:

```
Array: [-10, -3, 0, 5, 9]
         0   1  2  3  4

Step 1: Pick middle (index 2) → 0
              0
             / \

Step 2: Left half [-10, -3] → pick -10 (index 0)
              0
             / \
          -10   

Step 3: Right of -10 is [-3] → pick -3
              0
             / \
          -10   
            \
            -3

Step 4: Right half [5, 9] → pick 5 (index 3)
              0
             / \
          -10   5
            \
            -3

Step 5: Right of 5 is [9] → pick 9
              0
             / \
          -10   5
            \    \
            -3    9

Final Balanced BST!
```

---

## Key Insights

1. **Why `mid = left + (right - left) / 2`?**
   - Prevents integer overflow compared to `(left + right) / 2`
   - When left and right are large, their sum might exceed Integer.MAX_VALUE

2. **Height-Balanced Property**
   - By always choosing the middle element, we ensure equal distribution
   - Difference in heights of left and right subtrees ≤ 1

3. **Multiple Valid Answers**
   - Choosing middle-left vs middle-right gives different valid trees
   - Both are height-balanced BSTs

4. **BST Property Maintained**
   - Left subtree elements < root < Right subtree elements
   - This is guaranteed by the sorted array property

---

## Visual Comparison

### Unbalanced vs Balanced BST

```
Unbalanced (inserting in order):     Balanced (our approach):
        -10                                  0
          \                                 / \
          -3                             -10   5
            \                              \    \
             0                             -3    9
              \
               5        Height = 5         Height = 3
                \
                 9
```

---

## Alternative Approaches

### Using Random Middle Selection
You could randomly choose between middle-left and middle-right when array has even length:
```java
int mid = left + (right - left) / 2 + random.nextInt(2);
```
This gives different valid balanced BSTs on different runs.

---

## Common Mistakes to Avoid

1. ❌ Using `(left + right) / 2` → potential overflow
2. ❌ Not handling base case (left > right) → infinite recursion
3. ❌ Incorrect range splitting (forgetting mid-1 or mid+1)
4. ❌ Modifying the input array

---

## Summary

| Aspect | Details |
|--------|---------|
| **Time Complexity** | O(n) |
| **Space Complexity** | O(log n) recursion stack |
| **Approach** | Divide and Conquer |
| **Key Technique** | Always pick middle element |
| **Difficulty** | Easy |
| **Topics** | Tree, Binary Search Tree, Divide and Conquer, Recursion |
