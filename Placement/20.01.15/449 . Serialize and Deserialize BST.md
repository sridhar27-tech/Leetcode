# LeetCode 449: Serialize and Deserialize BST

## Problem Link
[Serialize and Deserialize BST - LeetCode](https://leetcode.com/problems/serialize-and-deserialize-bst/)

## Problem Statement
Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a **binary search tree**. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.

**The encoded string should be as compact as possible.**

### Example 1:
```
Input: root = [2,1,3]
Output: [2,1,3]
```

### Example 2:
```
Input: root = []
Output: []
```

### Constraints:
- The number of nodes in the tree is in the range `[0, 10^4]`
- `0 <= Node.val <= 10^4`
- The input tree is **guaranteed** to be a binary search tree

---

## Intuition

Since we're dealing with a **BST** (not just any binary tree), we can leverage the BST property to create a more compact serialization:
- **BST Property**: Left subtree values < root < Right subtree values
- We can serialize using **preorder traversal** only (no need for null markers!)
- During deserialization, we can reconstruct the tree using the BST property and value ranges

This is more efficient than the general binary tree serialization which requires null markers.

---

## Approach 1: Preorder Traversal with Delimiters (Simple)

### Algorithm for Serialization:
1. Perform preorder traversal (root → left → right)
2. Append each value to a string with a delimiter (comma or space)
3. Return the string

### Algorithm for Deserialization:
1. Split the string by delimiter
2. Use preorder values with BST property to reconstruct
3. For each value, determine if it belongs to left or right subtree based on range

### Java Implementation
```java
public class Codec {
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if (root == null) {
            return "";
        }
        
        StringBuilder sb = new StringBuilder();
        serializeHelper(root, sb);
        return sb.toString();
    }
    
    private void serializeHelper(TreeNode root, StringBuilder sb) {
        if (root == null) {
            return;
        }
        
        sb.append(root.val).append(",");
        serializeHelper(root.left, sb);
        serializeHelper(root.right, sb);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if (data.isEmpty()) {
            return null;
        }
        
        String[] values = data.split(",");
        return deserializeHelper(values, new int[]{0}, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    
    private TreeNode deserializeHelper(String[] values, int[] index, int min, int max) {
        if (index[0] >= values.length) {
            return null;
        }
        
        int val = Integer.parseInt(values[index[0]]);
        
        // Check if current value is within valid range for this subtree
        if (val < min || val > max) {
            return null;
        }
        
        // Create node and move to next value
        TreeNode root = new TreeNode(val);
        index[0]++;
        
        // Build left subtree (values must be < current value)
        root.left = deserializeHelper(values, index, min, val);
        
        // Build right subtree (values must be > current value)
        root.right = deserializeHelper(values, index, val, max);
        
        return root;
    }
}
```

### Time Complexity:
- **Serialize**: O(n) - visit each node once
- **Deserialize**: O(n) - process each value once

### Space Complexity:
- **Serialize**: O(n) - recursion stack (height of tree)
- **Deserialize**: O(n) - recursion stack + output tree

---

## Approach 2: Using Queue (Iterative Style)

```java
public class Codec {
    public String serialize(TreeNode root) {
        if (root == null) return "";
        
        StringBuilder sb = new StringBuilder();
        serialize(root, sb);
        return sb.toString();
    }
    
    private void serialize(TreeNode node, StringBuilder sb) {
        if (node == null) return;
        
        sb.append(node.val).append(",");
        serialize(node.left, sb);
        serialize(node.right, sb);
    }

    public TreeNode deserialize(String data) {
        if (data.isEmpty()) return null;
        
        Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(",")));
        return deserialize(queue, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    
    private TreeNode deserialize(Queue<String> queue, int min, int max) {
        if (queue.isEmpty()) return null;
        
        int val = Integer.parseInt(queue.peek());
        if (val < min || val > max) return null;
        
        queue.poll();
        TreeNode root = new TreeNode(val);
        root.left = deserialize(queue, min, val);
        root.right = deserialize(queue, val, max);
        
        return root;
    }
}
```

---

## Flow of Algorithm with Example

Let's trace through the tree: `[2,1,3]`

```
        2
       / \
      1   3
```

### Serialization Process:

```
1. Visit root (2) → sb = "2,"
2. Visit left (1) → sb = "2,1,"
3. No left of 1 → return
4. No right of 1 → return
5. Visit right (3) → sb = "2,1,3,"
6. No left of 3 → return
7. No right of 3 → return

Final serialized string: "2,1,3,"
```

### Deserialization Process:

```
Input: "2,1,3,"
Split: ["2", "1", "3"]

Step 1: index=0, val=2, range=(-∞, +∞)
├── Create node(2), index=1
├── Build left with range (-∞, 2)
│   └── index=1, val=1, range=(-∞, 2) ✓
│       ├── Create node(1), index=2
│       ├── Build left with range (-∞, 1)
│       │   └── index=2, val=3, 3 > 1 ✗ → null
│       └── Build right with range (1, 2)
│           └── index=2, val=3, 3 > 2 ✗ → null
│       └── Return node(1)
└── Build right with range (2, +∞)
    └── index=2, val=3, range=(2, +∞) ✓
        ├── Create node(3), index=3
        ├── Build left with range (2, 3)
        │   └── index=3 >= length → null
        └── Build right with range (3, +∞)
            └── index=3 >= length → null
        └── Return node(3)
└── Return node(2) with left=1, right=3

Reconstructed tree:
        2
       / \
      1   3
```

---

## Why This Works (BST Property)

### Key Insight:
In preorder traversal of a BST:
1. Current node value determines the range for left and right subtrees
2. Left subtree: all values in range `[min, current)`
3. Right subtree: all values in range `(current, max]`

### Range Validation:
```
Example: [5, 3, 2, 4, 7, 6, 8]
         5 (range: -∞ to +∞)
        / \
       3   7
      / \ / \
     2  4 6  8

When processing:
- 5: valid in (-∞, +∞), create node
- 3: valid in (-∞, 5), goes to left of 5
- 2: valid in (-∞, 3), goes to left of 3
- 4: valid in (3, 5), goes to right of 3
- 7: NOT in range (5, 5), backtrack to 5's right
- 7: valid in (5, +∞), goes to right of 5
- 6: valid in (5, 7), goes to left of 7
- 8: valid in (7, +∞), goes to right of 7
```

---

## Comparison with General Binary Tree Serialization

### General Binary Tree (needs null markers):
```
        2
       / \
      1   3
      
Serialization: "2,1,null,null,3,null,null"
```

### BST (no null markers needed):
```
        2
       / \
      1   3
      
Serialization: "2,1,3"
```

**Space Savings**: BST approach is much more compact!

---

## Alternative: Using Postorder

You can also use postorder traversal for serialization:

```java
public class Codec {
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        postorder(root, sb);
        return sb.toString();
    }
    
    private void postorder(TreeNode node, StringBuilder sb) {
        if (node == null) return;
        postorder(node.left, sb);
        postorder(node.right, sb);
        sb.append(node.val).append(",");
    }

    public TreeNode deserialize(String data) {
        if (data.isEmpty()) return null;
        String[] vals = data.split(",");
        int[] idx = new int[]{vals.length - 1};
        return build(vals, idx, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    
    private TreeNode build(String[] vals, int[] idx, int min, int max) {
        if (idx[0] < 0) return null;
        int val = Integer.parseInt(vals[idx[0]]);
        if (val < min || val > max) return null;
        
        TreeNode root = new TreeNode(val);
        idx[0]--;
        root.right = build(vals, idx, val, max);  // Process right first
        root.left = build(vals, idx, min, val);
        return root;
    }
}
```

---

## Key Points to Remember

1. **BST Property is Crucial**: Leveraging the BST property eliminates the need for null markers
2. **Range Checking**: Use min/max bounds to determine where each value belongs
3. **Preorder is Natural**: Root-first traversal makes reconstruction straightforward
4. **Index Tracking**: Use array wrapper `int[]` to pass index by reference
5. **Compact Encoding**: This approach produces the most compact serialization for BSTs

---

## Common Mistakes to Avoid

1. ❌ Forgetting that input is a **BST** (using general tree serialization)
2. ❌ Not updating index correctly during deserialization
3. ❌ Incorrect range boundaries (using `<=` instead of `<`)
4. ❌ Not handling empty string case
5. ❌ Using `Integer.parseInt()` without checking if array is exhausted

---

## Fixed Code for Your Solution

```java
public class Codec {  // Capital C!
    public String serialize(TreeNode root) {
        if (root == null) {
            return "";
        }
        
        StringBuilder sb = new StringBuilder();
        serializeHelper(root, sb);
        return sb.toString();
    }
    
    private void serializeHelper(TreeNode root, StringBuilder sb) {
        if (root == null) return;
        
        sb.append(root.val).append(",");
        serializeHelper(root.left, sb);
        serializeHelper(root.right, sb);
    }

    public String deserialize(String data) {
        if (data.isEmpty()) {
            return null;
        }
        
        String[] values = data.split(",");
        int[] index = {0};
        return deserializeHelper(values, index, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    
    private TreeNode deserializeHelper(String[] values, int[] index, int min, int max) {
        if (index[0] >= values.length) {
            return null;
        }
        
        int val = Integer.parseInt(values[index[0]]);
        
        if (val < min || val > max) {
            return null;
        }
        
        TreeNode root = new TreeNode(val);
        index[0]++;
        
        root.left = deserializeHelper(values, index, min, val);
        root.right = deserializeHelper(values, index, val, max);
        
        return root;
    }
}
```

---

## Summary

| Aspect | Details |
|--------|---------|
| **Time Complexity** | O(n) for both serialize and deserialize |
| **Space Complexity** | O(h) recursion stack, O(n) for result |
| **Approach** | Preorder traversal + BST range property |
| **Key Technique** | Range-based reconstruction |
| **Difficulty** | Medium |
| **Topics** | BST, Tree, String, Recursion, Design |
