# 74. Search a 2D Matrix

**Difficulty:** Medium  
**Problem Link:** [LeetCode 74 - Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/)

---

## Problem Statement

You are given an `m x n` integer matrix `matrix` with the following two properties:
- Each row is sorted in non-decreasing order.
- The first integer of each row is greater than the last integer of the previous row.

Given an integer `target`, return `true` if `target` is in matrix or `false` otherwise.

**Constraint:** You must write a solution in **O(log(m * n))** time complexity.

---

## Examples

### Example 1:
```
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true
```

### Example 2:
```
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false
```

---

## Visual Representation

![2D Matrix Search Visualization](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)

The matrix can be visualized as a flattened sorted array:
```
[1, 3, 5, 7, 10, 11, 16, 20, 23, 30, 34, 60]
```

---

## Core Idea & Intuition

### Key Insight
The matrix has two critical properties:
1. **Each row is sorted** in non-decreasing order
2. **First element of each row > Last element of previous row**

This means if we **flatten the 2D matrix into a 1D array**, it would be **completely sorted**! 

üí° **The trick:** We don't actually need to flatten it. We can treat the 2D matrix as a virtual 1D sorted array and apply **binary search** on it.

### Mapping Between 1D and 2D
Given a matrix with `m` rows and `n` columns:
- **1D index** ‚Üí **2D coordinates**: 
  - `row = index / n`
  - `col = index % n`
- **Total elements**: `m * n`

---

## Approach 1: Brute Force (Linear Search)

### Algorithm
Iterate through each element in the matrix and check if it equals the target.

### Code
```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        
        // Check every element
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == target) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

### Complexity Analysis
- **Time Complexity:** O(m √ó n) - We check every element
- **Space Complexity:** O(1)

### Why This Doesn't Work
‚ùå **Doesn't meet the O(log(m √ó n)) requirement**  
‚ùå **Doesn't utilize the sorted property of the matrix**

---

## Approach 2: Optimized Solution (Binary Search)

### Core Thinking

Since the matrix is essentially a sorted 1D array when flattened, we can:
1. Treat it as a virtual 1D sorted array of size `m √ó n`
2. Apply binary search on indices `0` to `m √ó n - 1`
3. Convert 1D index to 2D coordinates when accessing elements

### Algorithm Flow

**Step-by-step process:**

1. Initialize `left = 0`, `right = m √ó n - 1`
2. While `left <= right`:
   - Calculate `mid = left + (right - left) / 2`
   - Convert to 2D: `row = mid / n`, `col = mid % n`
   - Get value: `val = matrix[row][col]`
   - If `val == target`: return `true`
   - If `val < target`: search right half (`left = mid + 1`)
   - If `val > target`: search left half (`right = mid - 1`)
3. If not found, return `false`

### Example Walkthrough

**Given:** `matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]]`, `target = 11`

```
Matrix (m=3, n=4):
[1,  3,  5,  7]     indices: [0, 1, 2, 3]
[10, 11, 16, 20]    indices: [4, 5, 6, 7]
[23, 30, 34, 60]    indices: [8, 9, 10, 11]
```

**Iteration 1:**
- `left = 0`, `right = 11`
- `mid = 5` ‚Üí `row = 5/4 = 1`, `col = 5%4 = 1`
- `matrix[1][1] = 11` ‚úÖ **Found!**
- Return `true`

**Example 2:** `target = 13`

**Iteration 1:**
- `left = 0`, `right = 11`, `mid = 5`
- `matrix[1][1] = 11 < 13` ‚Üí `left = 6`

**Iteration 2:**
- `left = 6`, `right = 11`, `mid = 8`
- `matrix[2][0] = 23 > 13` ‚Üí `right = 7`

**Iteration 3:**
- `left = 6`, `right = 7`, `mid = 6`
- `matrix[1][2] = 16 > 13` ‚Üí `right = 5`

**Iteration 4:**
- `left = 6`, `right = 5` ‚Üí `left > right`
- Return `false` ‚ùå

### Code
```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        int left = 0, right = m * n - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            // Convert 1D index to 2D coordinates
            int row = mid / n;
            int col = mid % n;
            int val = matrix[row][col];
            
            if (val == target) {
                return true;
            } else if (val < target) {
                left = mid + 1;  // Search right half
            } else {
                right = mid - 1; // Search left half
            }
        }
        
        return false;
    }
}
```

### Complexity Analysis
- **Time Complexity:** O(log(m √ó n)) - Binary search on m √ó n elements
- **Space Complexity:** O(1) - Only using a few variables

---

## Visual Example: Index Mapping

```
2D Matrix (3√ó4):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1  ‚îÇ 3  ‚îÇ 5  ‚îÇ 7  ‚îÇ  Row 0
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 10 ‚îÇ 11 ‚îÇ 16 ‚îÇ 20 ‚îÇ  Row 1
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 23 ‚îÇ 30 ‚îÇ 34 ‚îÇ 60 ‚îÇ  Row 2
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îò

1D Virtual Array (indices 0-11):
[1, 3, 5, 7, 10, 11, 16, 20, 23, 30, 34, 60]
 0  1  2  3   4   5   6   7   8   9  10  11

Mapping Formula (n=4):
‚Ä¢ Index 5 ‚Üí row = 5/4 = 1, col = 5%4 = 1 ‚Üí matrix[1][1] = 11
‚Ä¢ Index 8 ‚Üí row = 8/4 = 2, col = 8%4 = 0 ‚Üí matrix[2][0] = 23
```

---

## Alternative Approaches

### Approach 3: Two Binary Searches
1. First binary search to find the correct row
2. Second binary search within that row

**Time Complexity:** O(log m + log n) = O(log(m √ó n))

This is also valid but slightly more complex to implement.

---

## Key Takeaways

‚úÖ **Recognize the pattern:** When a 2D matrix is sorted both row-wise and the first element of each row is greater than the last of the previous row, treat it as a 1D sorted array

‚úÖ **Index conversion is key:** Master the formulas `row = index / n` and `col = index % n`

‚úÖ **Binary search mindset:** Always look for ways to apply binary search on sorted data

‚úÖ **Time complexity requirement:** The O(log(m √ó n)) constraint is a hint that binary search is needed

---

## Related Problems
- [240. Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/) (Different properties)
- [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)
- [704. Binary Search](https://leetcode.com/problems/binary-search/)

---

**Tags:** `Binary Search` `Matrix` `Array`
