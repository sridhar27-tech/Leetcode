# 62. Unique Paths

**Difficulty:** Medium  
**Link:** [LeetCode Problem #62](https://leetcode.com/problems/unique-paths/)

---

## Problem Statement

There is a robot on an `m x n` grid. The robot is initially located at the top-left corner (i.e., `grid[0][0]`). The robot tries to move to the bottom-right corner (i.e., `grid[m - 1][n - 1]`). The robot can only move either **down** or **right** at any point in time.

Given the two integers `m` and `n`, return the number of possible unique paths that the robot can take to reach the bottom-right corner.

### Example 1:
```
Input: m = 3, n = 7
Output: 28
```

### Example 2:
```
Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Down -> Down
2. Down -> Down -> Right
3. Down -> Right -> Down
```

### Constraints:
- `1 <= m, n <= 100`
- The answer will be less than or equal to `2 * 10^9`

---

## Core Idea & Intuition

The fundamental insight is that **to reach any cell (i, j), the robot must have come from either:**
- The cell above it: `(i-1, j)`, or
- The cell to the left: `(i, j-1)`

Therefore, the number of ways to reach cell `(i, j)` is the **sum of ways to reach the cell above and the cell to the left**:

```
paths[i][j] = paths[i-1][j] + paths[i][j-1]
```

### Key Observations:
1. **Base Cases:** There's only **1 way** to reach any cell in the first row (keep moving right) and **1 way** to reach any cell in the first column (keep moving down).
2. **No Backtracking:** Since we can only move right or down, we never revisit cells.
3. **Optimal Substructure:** The problem exhibits optimal substructure - the solution to a larger problem depends on solutions to smaller subproblems.

### Visual Representation:

![Grid Paths Example](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

---

## Solution Approaches

### 1. Memoization (Top-Down Dynamic Programming)

**Time Complexity:** O(m × n)  
**Space Complexity:** O(m × n) for dp array + O(m + n) for recursion stack

```java
class Solution {
    int[][] dp;
    
    public int uniquePaths(int m, int n) {
        dp = new int[m][n];
        return solve(0, 0, m, n);
    }
    
    int solve(int i, int j, int m, int n) {
        // Out of bounds - invalid path
        if (i >= m || j >= n) return 0;
        
        // Reached destination - found 1 valid path
        if (i == m - 1 && j == n - 1) return 1;
        
        // Already computed - return cached result
        if (dp[i][j] != 0) return dp[i][j];
        
        // Explore both directions: down and right
        dp[i][j] = solve(i + 1, j, m, n) + solve(i, j + 1, m, n);
        
        return dp[i][j];
    }
}
```

#### Memoization Flow with Example (m=3, n=3):

Let's trace the execution for a 3×3 grid:

```
Initial Grid (indices):
[0,0] [0,1] [0,2]
[1,0] [1,1] [1,2]
[2,0] [2,1] [2,2]
```

**Step-by-step Execution:**

1. **Start:** `solve(0,0,3,3)`
   - Not base case, dp[0][0] = 0, so compute
   - Recursively call: `solve(1,0,3,3)` + `solve(0,1,3,3)`

2. **Branch 1:** `solve(1,0,3,3)`
   - Continue recursing down...
   - Eventually reaches `solve(2,0,3,3)`
   - From `solve(2,0,3,3)`: can only go right
     - `solve(2,1,3,3)` → `solve(2,2,3,3)` = 1 (destination!)
   - Backtrack and cache results

3. **Branch 2:** `solve(0,1,3,3)`
   - Explores the right path
   - Similar recursive exploration

**Memoization Table After Computation:**

```
dp array (paths from each cell to destination):
[6] [3] [1]
[3] [2] [1]
[1] [1] [1]
```

**Visualization of Recursive Calls:**

```
                    solve(0,0)
                   /          \
            solve(1,0)      solve(0,1)
           /        \        /        \
    solve(2,0)  solve(1,1)  solve(1,1)  solve(0,2)
       /    \      /    \      /    \       /    \
     ...   ...   ...   ...   ...   ...    ...   ...
```

The memoization prevents recalculating `solve(1,1)` multiple times - it's computed once and reused.

---

### 2. Tabulation (Bottom-Up Dynamic Programming)

**Time Complexity:** O(m × n)  
**Space Complexity:** O(m × n)

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        
        // Initialize first column - only 1 way (keep going down)
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        
        // Initialize first row - only 1 way (keep going right)
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1;
        }
        
        // Fill the rest of the table
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                // Paths from above + paths from left
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        
        return dp[m - 1][n - 1];
    }
}
```

#### Tabulation Flow with Example (m=3, n=7):

**Step 1: Initialize Base Cases**
```
[1] [1] [1] [1] [1] [1] [1]
[1] [0] [0] [0] [0] [0] [0]
[1] [0] [0] [0] [0] [0] [0]
```

**Step 2: Fill Row by Row**
```
[1] [1] [1] [1] [1] [1] [1]
[1] [2] [3] [4] [5] [6] [7]
[1] [0] [0] [0] [0] [0] [0]
```

At dp[1][1]: paths from dp[0][1] (1) + dp[1][0] (1) = 2
At dp[1][2]: paths from dp[0][2] (1) + dp[1][1] (2) = 3
...and so on

**Step 3: Final Table**
```
[1]  [1]  [1]  [1]  [1]  [1]  [1]
[1]  [2]  [3]  [4]  [5]  [6]  [7]
[1]  [3]  [6] [10] [15] [21] [28]
```

**Answer:** dp[2][6] = **28**

---

### 3. Space-Optimized Tabulation (1D Array)

**Time Complexity:** O(m × n)  
**Space Complexity:** O(n)

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[] dp = new int[n];
        
        // Initialize first row - all cells have 1 path
        for (int j = 0; j < n; j++) {
            dp[j] = 1;
        }
        
        // Process each row
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                // dp[j] currently holds dp[i-1][j] (above)
                // dp[j-1] holds dp[i][j-1] (left)
                dp[j] = dp[j] + dp[j - 1];
            }
        }
        
        return dp[n - 1];
    }
}
```

#### How Space Optimization Works:

Instead of maintaining a full 2D array, we only keep track of the current row. The key insight is that `dp[i][j]` only depends on `dp[i-1][j]` (directly above) and `dp[i][j-1]` (to the left in current row).

---

## Comparison of Approaches

| Approach | Time | Space | Pros | Cons |
|----------|------|-------|------|------|
| **Memoization** | O(m×n) | O(m×n) + O(m+n) stack | Intuitive, easy to code | Extra recursion overhead |
| **Tabulation** | O(m×n) | O(m×n) | No recursion overhead | Need to think bottom-up |
| **Space-Optimized** | O(m×n) | O(n) | Minimal space usage | Less intuitive |

---

## Mathematical Approach (Combinatorics)

There's also a pure mathematical solution using combinations:

To reach from (0,0) to (m-1, n-1), the robot must make:
- **(m-1) down moves**
- **(n-1) right moves**
- **Total moves = (m-1) + (n-1) = m+n-2**

The problem becomes: "In how many ways can we arrange (m-1) down moves and (n-1) right moves?"

**Answer:** C(m+n-2, m-1) = C(m+n-2, n-1)

```java
class Solution {
    public int uniquePaths(int m, int n) {
        long result = 1;
        int totalMoves = m + n - 2;
        int k = Math.min(m - 1, n - 1);
        
        for (int i = 1; i <= k; i++) {
            result = result * (totalMoves - k + i) / i;
        }
        
        return (int) result;
    }
}
```

**Time Complexity:** O(min(m, n))  
**Space Complexity:** O(1)

---

## Summary

The Unique Paths problem is a classic introduction to dynamic programming. The key insights are:

1. **Recognize the overlapping subproblems** - many paths pass through the same cells
2. **Identify the recurrence relation** - paths to (i,j) = paths to (i-1,j) + paths to (i,j-1)
3. **Choose the right approach** - memoization for intuition, tabulation for efficiency
4. **Consider optimizations** - space can be reduced from O(m×n) to O(n)

This problem teaches fundamental DP concepts that apply to many grid-based path-finding problems!
