# ğŸ§—â€â™‚ï¸ LeetCode 70: Climbing Stairs

**LeetCode Number:** 70
**Problem Link:** [https://leetcode.com/problems/climbing-stairs/](https://leetcode.com/problems/climbing-stairs/)

---

## ğŸ“˜ Problem Statement

You are climbing a staircase. It takes `n` steps to reach the top.

Each time, you can either climb **1 step** or **2 steps**.

Return the **number of distinct ways** you can climb to the top.

---

## ğŸ§  Intuition

At every step, you have **two choices**:

* Take **1 step** from the previous stair
* Take **2 steps** from two stairs below

So, the total number of ways to reach step `n` is:

```
ways(n) = ways(n-1) + ways(n-2)
```

This is **exactly the Fibonacci pattern**.

---

## ğŸ§© Core Idea (Thinking View)

* To reach step `n`, you must come from:

  * Step `n-1` (1 jump)
  * Step `n-2` (2 jump)
* Count all possible ways to reach those steps
* Add them together

This naturally leads to **recursion**, but recursion alone is inefficient â†’ we optimize it using **Dynamic Programming**.

---

## ğŸŒ Brute Force Approach (Recursion)

### ğŸ” Idea

Try all possible combinations using recursion.

### âŒ Drawback

* Recomputes the same subproblems again and again
* Exponential time complexity

### ğŸ’» Code (Java)

```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 2) return n;
        return climbStairs(n - 1) + climbStairs(n - 2);
    }
}
```

### â± Time & Space Complexity

* **Time:** O(2â¿)
* **Space:** O(n) (recursive stack)

---

## âš¡ Optimized Approach (Dynamic Programming)

### ğŸ” Idea

Store previously computed results so we donâ€™t recompute them.

### ğŸ’» Code (Java)

```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 2) return n;
        
        int prev2 = 1; // ways to reach step 1
        int prev1 = 2; // ways to reach step 2
        
        for (int i = 3; i <= n; i++) {
            int curr = prev1 + prev2;
            prev2 = prev1;
            prev1 = curr;
        }
        return prev1;
    }
}
```

### â± Time & Space Complexity

* **Time:** O(n)
* **Space:** O(1)

---

## ğŸ”„ Algorithm Flow (Step-by-Step Example)

### Example: `n = 5`

| Step | Ways    |
| ---- | ------- |
| 1    | 1       |
| 2    | 2       |
| 3    | 3 (1+2) |
| 4    | 5 (2+3) |
| 5    | 8 (3+5) |

### Explanation

* Step 3 â†’ (1+2)
* Step 4 â†’ (2+3)
* Step 5 â†’ (3+5)

Final Answer = **8 ways**

---

## ğŸ–¼ï¸ Visual Explanation

### Fibonacci Tree (Recursion Overlap)

![Recursion Tree](https://upload.wikimedia.org/wikipedia/commons/9/9e/Fibonacci_tree.svg)

### Staircase Visualization

![Climbing Stairs](https://leetcode.com/problems/climbing-stairs/Figures/70/climbing_stairs.png)

---

## âœ… Key Takeaways

* This is a **classic DP problem**
* Recognize the **Fibonacci pattern**
* Brute force is intuitive but inefficient
* Optimized DP gives linear time and constant space

---

## ğŸ Final Thought

> If a problem asks for **number of ways** and depends on **previous states**, think **Dynamic Programming** ğŸ§ âœ¨

Happy Coding ğŸš€
