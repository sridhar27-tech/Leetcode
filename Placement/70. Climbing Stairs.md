# Climbing Stairs (Dynamic Programming)

## LeetCode Information

* **LeetCode Number:** 70
* **Problem Link:** [https://leetcode.com/problems/climbing-stairs/](https://leetcode.com/problems/climbing-stairs/)

---

## Problem Statement

You are climbing a staircase with `n` steps. At each step, you can either climb **1 step** or **2 steps**.
Determine the number of **distinct ways** to reach the top.

---

## Intuition

To reach step `n`, you must come from:

* step `n-1` by taking **1 step**, or
* step `n-2` by taking **2 steps**.

There are no other possibilities. So the total number of ways to reach step `n` is the sum of the ways to reach `n-1` and `n-2`.

This immediately gives a Fibonacci-like pattern.

---

## Core Idea (Thinking View)

* This is a **counting problem**, not a path or minimum-cost problem.
* The current answer depends only on the **previous two answers**.
* Storing all previous values is unnecessary; only the last two are needed.

This makes it a perfect fit for **Dynamic Programming with space optimization**.

---

## Recurrence Relation

Let `dp[i]` be the number of ways to reach step `i`.

```
dp[i] = dp[i - 1] + dp[i - 2]
```

### Base Cases

```
dp[0] = 1  // one way: stay where you are
dp[1] = 1  // one way: take one step
```

---

## Brute Force Solution (Recursion)

This approach tries all possible ways by recursion.

### Code

```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 1) return 1;
        return climbStairs(n - 1) + climbStairs(n - 2);
    }
}
```

### Problems with Brute Force

* Recomputes the same subproblems again and again
* Time Complexity: **O(2^n)** (exponential)
* Will **TLE** for large `n`

---

## Optimized Solution (Dynamic Programming)

We store only the last two results.

### Code (Space Optimized)

```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 1) return 1;

        int prev2 = 1; // dp[0]
        int prev1 = 1; // dp[1]

        for (int i = 2; i <= n; i++) {
            int curr = prev1 + prev2;
            prev2 = prev1;
            prev1 = curr;
        }
        return prev1;
    }
}
```

### Complexity

* **Time:** O(n)
* **Space:** O(1)

---

## Algorithm Flow (Example)

### Example: `n = 5`

| Step | Ways |
| ---- | ---- |
| 0    | 1    |
| 1    | 1    |
| 2    | 2    |
| 3    | 3    |
| 4    | 5    |
| 5    | 8    |

### Iteration Flow

```
Start:
prev2 = 1, prev1 = 1

Step 2: curr = 1 + 1 = 2
Step 3: curr = 2 + 1 = 3
Step 4: curr = 3 + 2 = 5
Step 5: curr = 5 + 3 = 8
```

Answer = **8 ways**

---

## Visualization (Conceptual)

```
Step 3
↑  ↑
|  |
1  2

Ways(3) = Ways(2) + Ways(1)
```

Each step branches into two smaller subproblems, which DP collapses into simple additions.

---

## Key Takeaways

* This is a **Fibonacci problem in disguise**
* Recursion without memoization is inefficient
* Iterative DP with constant space is optimal
* Very common interview and contest problem

---

## Summary

If a problem asks for the number of ways and each state depends on a fixed number of previous states, think **Dynamic Programming** first.

Climbing Stairs is the cleanest example of this pattern.
