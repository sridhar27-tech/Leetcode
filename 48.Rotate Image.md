# ğŸŒ€ LeetCode 48 â€” Rotate Image (90Â° Clockwise)

### ğŸ“Œ Problem Link

[https://leetcode.com/problems/rotate-image/](https://leetcode.com/problems/rotate-image/)

---

## ğŸ§© Problem Summary

You are given an `n x n` 2D matrix representing an image.
Rotate the image **in-place** by **90 degrees clockwise**.

That means:
â›” You **cannot** use another matrix to store the result.

### Example

```
Input:
[
 [1,2,3],
 [4,5,6],
 [7,8,9]
]

Output:
[
 [7,4,1],
 [8,5,2],
 [9,6,3]
]
```

---

## ğŸ§  Core Idea & Intuition (Thinking View)

Visualize the matrix as layers (like an onion ğŸ§…).

Each 90Â° rotation means:

```
top â†’ right
right â†’ bottom
bottom â†’ left
left â†’ top
```

Another powerful idea:

> **Rotating 90Â° clockwise = Transpose + Reverse each row**

Why?

```
Original:       Transpose:       Reverse Rows:
1 2 3           1 4 7            7 4 1
4 5 6    -->    2 5 8    -->     8 5 2
7 8 9           3 6 9            9 6 3
```

DONE ğŸ¯
And everything is **in-place**.

---

## ğŸ–¼ Helpful Visuals (Internet references)

Think of rotating a square:

![Matrix Rotate](https://upload.wikimedia.org/wikipedia/commons/4/4c/Matrix_rotation.png)

Another way â€” layer rotation:

![Layer Rotation](https://miro.medium.com/v2/resize\:fit:720/format\:webp/1*bY6DPd7OJbRRqtD9h5pzQQ.png)

*(Images are hosted resources â€” you donâ€™t need to upload anything)*

---

## ğŸ¢ Brute Force Solution (Using Extra Matrix)

### ğŸ•’ Time Complexity â€” `O(nÂ²)`

### ğŸ§  Space Complexity â€” `O(nÂ²)` (not allowed in LeetCode â€” but good for understanding)

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        int[][] temp = new int[n][n];

        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                temp[j][n - 1 - i] = matrix[i][j];
            }
        }

        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                matrix[i][j] = temp[i][j];
            }
        }
    }
}
```

Good for learning â€” âŒ but **violates in-place rule**.

---

## âš¡ Optimized In-Place Solution (Transpose + Reverse)

### ğŸ•’ Time Complexity â€” `O(nÂ²)`

### ğŸ“¦ Space Complexity â€” `O(1)`

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;

        // Step 1: Transpose the matrix
        for(int i = 0; i < n; i++){
            for(int j = i + 1; j < n; j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }

        // Step 2: Reverse each row
        for(int i = 0; i < n; i++){
            int left = 0, right = n - 1;

            while(left < right){
                int temp = matrix[i][left];
                matrix[i][left] = matrix[i][right];
                matrix[i][right] = temp;

                left++;
                right--;
            }
        }
    }
}
```

---

## ğŸ”„ Example Walkthrough (Step-by-Step)

### Input

```
[
 [1,2,3],
 [4,5,6],
 [7,8,9]
]
```

### ğŸ§® Step 1 â€” Transpose (swap across diagonal)

```
[
 [1,4,7],
 [2,5,8],
 [3,6,9]
]
```

### ğŸ” Step 2 â€” Reverse each row

```
[
 [7,4,1],
 [8,5,2],
 [9,6,3]
]
```

ğŸ¯ Done!

---

## ğŸ§  Intuition â€” In Plain English

Imagine turning a photo clockwise.
Every element moves to a **new fixed position**.

Instead of rotating one-by-one, we:

âœ” Flip across the diagonal (transpose)
âœ” Then flip horizontally

This perfectly simulates rotation.

And the best part?

> **We never allocate another matrix â€” true in-place rotation.**

---

## ğŸ Final Takeaways

âœ” Rotating 90Â° clockwise = **Transpose â†’ Reverse rows**
âœ” Works **in-place**
âœ” Guaranteed `O(nÂ²)` time
âœ” One of the best matrix manipulation patterns

---
