# ğŸ” LeetCode 33 â€” Search in Rotated Sorted Array

### ğŸ“Œ Problem Link

Search in Rotated Sorted Array â€” LeetCode #33

---

## ğŸ§© Problem Summary

Youâ€™re given:

* A **strictly increasing sorted array**
* Then it is **rotated at some pivot**
* A **target value**

Return the **index of the target**, or `-1` if itâ€™s not present.

Example:

```
Input:  nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

âš ï¸ You must solve it in **O(log n)** time.

---

## ğŸ’¡ Core Idea & Intuition (Thinking View)

Imagine a sorted array like:

```
[0,1,2,4,5,6,7]
```

Now rotate it:

```
[4,5,6,7,0,1,2]
```

Even though it looks messy â€” **at least ONE half of the array is still sorted** at any point.

So at every step of binary search:

âœ” Either **left half is sorted**,
âœ” Or **right half is sorted**

We **identify the sorted half**, then check:

* Does the target lie inside that sorted half?

  * Yes â†’ search there
  * No â†’ search the other half

Repeat until found.

This keeps time complexity **O(log n)**.

---

## ğŸ¢ Brute Force Solution (Linear Search)

### ğŸ•’ Time: `O(n)`

### ğŸ§  Idea: Just scan the whole array.

```java
class Solution {
    public int search(int[] nums, int target) {
        for(int i = 0; i < nums.length; i++){
            if(nums[i] == target){
                return i;
            }
        }
        return -1;
    }
}
```

Simple â€” but **not optimal** because the requirement is `O(log n)`.

---

## âš¡ Optimized Solution â€” Binary Search in Rotated Array

### ğŸ•’ Time: `O(log n)`

### ğŸ§  Core Idea:

At each step:

1. Find `mid`
2. Check which side is sorted
3. Decide where the target lies
4. Discard the other half

### âœ… Java Implementation

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;

        while(left <= right){

            int mid = left + (right - left) / 2;

            if(nums[mid] == target)
                return mid;

            // Check if left half is sorted
            if(nums[left] <= nums[mid]){

                // Target lies in sorted left half
                if(nums[left] <= target && target < nums[mid])
                    right = mid - 1;
                else
                    left = mid + 1;

            } else { 
                // Right half is sorted

                if(nums[mid] < target && target <= nums[right])
                    left = mid + 1;
                else
                    right = mid - 1;
            }
        }
        return -1;
    }
}
```

---

## ğŸ”„ Example Walkthrough (Step-by-Step)

### Input

```
nums = [4,5,6,7,0,1,2]
target = 0
```

| left | mid | right | nums[mid] | Which half sorted? | Target in sorted half? | Next                 |
| ---- | --- | ----- | --------- | ------------------ | ---------------------- | -------------------- |
| 0    | 3   | 6     | 7         | Left sorted (4â€“7)  | 0 NOT in 4â€“7           | Move right â†’ left=4  |
| 4    | 5   | 6     | 1         | Left sorted (0â€“1)  | 0 IS in 0â€“1            | Move right â†’ right=4 |
| 4    | 4   | 4     | 0         | Found!             | â€”                      | Return 4             |

ğŸ‰ **Answer = 4**

---

## ğŸ§  Intuition Summary (In Plain English)

Think like this:

> â€œEven though the array is rotated, one side is always a normal sorted array.
> Use binary search only inside the side where the target can logically exist.â€

This keeps efficiency high.

---

## ğŸ–¼ Visual (Concept Diagram â€” recreated)

```
Original sorted:
0 1 2 3 4 5 6

Rotated:
4 5 6 0 1 2 3
^       ^
L       R

Left sorted: 4 5 6
Right sorted: 0 1 2 3
```

At every step â†’ **one sorted block always exists.**

---

## ğŸ Final Takeaway

âœ” Use **binary search logic**
âœ” Find **sorted half first**
âœ” Check if **target fits inside it**
âœ” Narrow search
âœ” Repeat until found

---
