# ğŸŒ€ LeetCode 153 â€” Find Minimum in Rotated Sorted Array

### ğŸ“Œ Problem Link

[https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)

---

## ğŸ§© Problem Summary

You are given an array:

* originally **sorted in strictly increasing order**
* but then **rotated at some pivot**

Your task is to **find the minimum element** in the array.

âš ï¸ You must solve it in **O(log n)** time.

### Example

```
Input:  nums = [3,4,5,1,2]
Output: 1
```

---

## ğŸ§  Core Idea & Intuition (Thinking View)

Think of a rotated sorted array like a sorted array thatâ€™s been â€œbrokenâ€ at some point:

```
Original:   [1, 2, 3, 4, 5]
Rotated:    [4, 5, 1, 2, 3]
```

Key observations:

âœ” The array is still **partially sorted**
âœ” The **minimum element is the only element where order breaks**

So the goal is to **binary search for the â€œbreak-pointâ€**.

At any index `mid`:

* If `nums[mid] > nums[right]`
  â†’ the minimum lies **to the right of mid**
* Else
  â†’ the minimum lies **on the left including mid**

We shrink the range until only the minimum remains.

---

## ğŸ¢ Brute Force Solution (Linear Search)

### ğŸ•’ Time Complexity â€” `O(n)`

### ğŸ§  Idea â€” Scan every element, track the minimum.

```java
class Solution {
    public int findMin(int[] nums) {
        int min = nums[0];
        for(int n : nums){
            if(n < min){
                min = n;
            }
        }
        return min;
    }
}
```

âœ” Simple
âŒ But **not optimal**

---

## âš¡ Optimized Solution â€” Binary Search

### ğŸ•’ Time Complexity â€” `O(log n)`

### ğŸ§  Space Complexity â€” `O(1)`

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;

        while(left < right){

            int mid = left + (right - left) / 2;

            // If mid element is greater than right,
            // the minimum lies to the right of mid
            if(nums[mid] > nums[right]){
                left = mid + 1;
            } 
            // Otherwise, the minimum lies on the left (including mid)
            else{
                right = mid;
            }
        }

        return nums[left]; 
    }
}
```

---

## ğŸ”„ Example Walkthrough (Step-by-Step)

### Input

```
nums = [4,5,6,7,0,1,2]
```

| left | mid | right | nums[mid] | nums[right] | Meaning                        | Action             |
| ---- | --- | ----- | --------- | ----------- | ------------------------------ | ------------------ |
| 0    | 3   | 6     | 7         | 2           | mid > right â†’ minimum on right | left = mid + 1 = 4 |
| 4    | 5   | 6     | 1         | 2           | mid < right â†’ minimum on left  | right = mid = 5    |
| 4    | 4   | 5     | 0         | 1           | mid < right â†’ left side        | right = mid = 4    |

Now `left == right == 4`

ğŸ¯ Minimum = `nums[4] = 0`

---

## ğŸ§  Intuition â€” In Plain English

Imagine rotating a sorted array. The **largest element sits just before the smallest**.

Binary search helps us detect which side still behaves like sorted order:

* If the right side is smaller â†’ go right
* If the right side is larger â†’ go left

We gradually narrow down to the exact pivot point â€” which is the **minimum value**.

---

## ğŸ–¼ Visual Idea (Concept Sketch)

```
Sorted:     1 2 3 4 5 6
Rotated:    4 5 6 1 2 3
                    ^
                 Minimum
```

At every binary search step â€” at least **one side is sorted**, and we use that fact to decide where the minimum lies.

---

## ğŸ Final Takeaway

âœ” Use **binary search**
âœ” Compare `nums[mid]` with `nums[right]`
âœ” Decide which half to discard
âœ” Continue until one element remains
âœ” That element = **minimum**

---
