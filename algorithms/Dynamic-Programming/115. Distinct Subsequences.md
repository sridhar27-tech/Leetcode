# **115. Distinct Subsequences — Explanation & Notes**

## **Problem**

**LeetCode 115. Distinct Subsequences**
**Difficulty:** Hard
**Tags:** Dynamic Programming, String, Memoization

---

## **Description**

Given two strings `s` and `t`, return the number of **distinct subsequences** of `s` that equal `t`.

A subsequence of a string is created by deleting some characters (possibly none) without changing the order of the remaining characters.

The output always fits in a 32-bit signed integer.

---

## **Examples**

### **Example 1**

**Input:**

```
s = "rabbbit"
t = "rabbit"
```

**Output:**

```
3
```

**Explanation:**
There are 3 distinct ways to form `"rabbit"` as a subsequence of `"rabbbit"`.

---

### **Example 2**

**Input:**

```
s = "babgbag"
t = "bag"
```

**Output:**

```
5
```

**Explanation:**
There are 5 distinct ways to form `"bag"` as a subsequence of `"babgbag"`.

---

# **What I Struggled With**

Before arriving at the correct solution, several misconceptions slowed down the reasoning:

### **1. Trying to *construct* subsequences**

A natural but incorrect instinct was:

* build an array of characters
* track matched sequences
* backtrack manually
* search for next occurrences

This treats the problem like *explicit string generation*, which quickly becomes unmanageable.

### **Correct insight:**

Counting subsequences does **not** require building them.
It only requires knowing:

* Where we are in `s` (index `i`)
* Where we are in `t` (index `j`)

This pair `(i, j)` represents the entire state of your progress.

---

### **2. Trying to “rewind pointers” manually**

The idea of:

* increasing i
* increasing j
* and then decreasing j when finishing a match
  does not work because:

A backtracking search tree can have many branches.
You cannot “go back” using only pointer subtraction.
You lose track of which decisions led to the current state.

### **Correct insight:**

We never backtrack using pointer arithmetic.
Instead, recursion handles branching naturally:

From state `(i, j)` we explore:

1. Skip the current char in `s`:
   `(i+1, j)`

2. If they match, use it:
   `(i+1, j+1)`

The recursion explores both futures. Memoization prevents repeated work.

---

### **3. Forgetting the pruning condition**

If the remaining length of `s` is less than the remaining requirement of `t`, the match is impossible.

Condition:

```
len(s) - i < len(t) - j
```

This greatly reduces recursion time.

---

# **Approach 1: Memoized DFS (Top-Down DP)**

### **Idea**

Define:

`dfs(i, j)` = number of ways to form `t[j:]` from `s[i:]`.

Transitions:

* Skip `s[i]`: `dfs(i+1, j)`
* If characters match:
  `dfs(i+1, j+1)` (use this character)

Base cases:

* If `j == len(t)`: we formed the whole target → return 1
* If `i == len(s)`: no characters left in `s` → return 0
* If remaining `s` < remaining `t`: impossible → return 0

Memoization ensures each `(i,j)` is solved once.

---

## ** (Memoized DFS Solution)**

```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        if len(t) > len(s):
            return 0

        memo = {}

        def dfs(i, j):
            if i == len(s) or j == len(t) or len(s) - i < len(t) - j:
                return int(j == len(t))
            if (i, j) in memo:
                return memo[(i, j)]

            ans = dfs(i + 1, j)
            if s[i] == t[j]:
                ans += dfs(i + 1, j + 1)
            memo[(i, j)] = ans
            return ans

        return dfs(0, 0)
```

This correctly counts all distinct subsequences using recursion and memoization.

---

# **Approach 2: Bottom-Up DP (1D array)**

### **Idea**

Let `dp[j] = number of ways to form t[0..j-1] so far`.

Initialize:

```
dp[0] = 1    # empty t can always be formed
```

Process each character of `s`, and update `dp` backwards:

```
for char in s:
    for j from len(t)-1 down to 0:
        if s[i] == t[j]:
            dp[j+1] += dp[j]
```

Return: `dp[len(t)]`

### **Key detail:**

We iterate `j` backwards so updates don’t overwrite needed values.

---
```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        dp = [0] * (n + 1)
        dp[0] = 1

        for i in range(m):
            for j in range(n - 1, -1, -1):
                if s[i] == t[j]:
                    dp[j + 1] += dp[j]

        return dp[n]
```


# **Final Notes**

* The problem becomes simple once you treat it as a **counting DP problem**, not a **subsequence construction problem**.
* State `(i, j)` is the entire story.
* Two choices (skip / take) define the recursion.
* Memo or DP collapses exponential branching into polynomial time.

# **Other langauge's implementations**
---

# **Top-Down (DFS + Memo)**

Same logic as your Python version, rewritten properly in Java and JS.

---

## **Java – Top-Down Memo**

```java
class Solution {
    public int numDistinct(String s, String t) {
        int n = s.length(), m = t.length();
        if (m > n) return 0;

        Integer[][] memo = new Integer[n][m];

        return dfs(0, 0, s, t, memo);
    }

    private int dfs(int i, int j, String s, String t, Integer[][] memo) {
        if (j == t.length()) return 1;
        if (i == s.length()) return 0;
        if (s.length() - i < t.length() - j) return 0;

        if (memo[i][j] != null) return memo[i][j];

        int ans = dfs(i + 1, j, s, t, memo);

        if (s.charAt(i) == t.charAt(j))
            ans += dfs(i + 1, j + 1, s, t, memo);

        memo[i][j] = ans;
        return ans;
    }
}
```

---

## **JavaScript – Top-Down Memo**

```javascript
var numDistinct = function (s, t) {
    const n = s.length, m = t.length;
    if (m > n) return 0;

    const memo = Array.from({ length: n }, () => Array(m).fill(undefined));

    function dfs(i, j) {
        if (j === m) return 1;
        if (i === n) return 0;
        if (n - i < m - j) return 0;

        if (memo[i][j] !== undefined) return memo[i][j];

        let ans = dfs(i + 1, j);

        if (s[i] === t[j]) {
            ans += dfs(i + 1, j + 1);
        }

        memo[i][j] = ans;
        return ans;
    }

    return dfs(0, 0);
};
```

---

# **Bottom-Up DP**

Iterative 2D table fill.
No recursion.
No memo.
Just loops doing loops things.

---

## **Java – Bottom-Up**

```java
class Solution {
    public int numDistinct(String s, String t) {
        int n = s.length(), m = t.length();
        int[][] dp = new int[n + 1][m + 1];

        for (int i = 0; i <= n; i++) dp[i][0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                dp[i][j] = dp[i - 1][j];
                if (s.charAt(i - 1) == t.charAt(j - 1))
                    dp[i][j] += dp[i - 1][j - 1];
            }
        }

        return dp[n][m];
    }
}
```

---

## **JavaScript – Bottom-Up**

```javascript
var numDistinct = function (s, t) {
    const n = s.length, m = t.length;

    const dp = Array.from({ length: n + 1 }, () =>
        Array(m + 1).fill(0)
    );

    for (let i = 0; i <= n; i++) dp[i][0] = 1;

    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= m; j++) {
            dp[i][j] = dp[i - 1][j];
            if (s[i - 1] === t[j - 1]) {
                dp[i][j] += dp[i - 1][j - 1];
            }
        }
    }

    return dp[n][m];
};
```




