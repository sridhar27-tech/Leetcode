Here’s a clean, ready-to-save **Markdown file** version of your notes and code — formatted properly so you can keep it as part of your LeetCode study log:

---

````markdown
# LeetCode 977 – Squares of a Sorted Array

## What I Can Do
In a normal way, I can just square each number and use `.sort()`.  
That gives a time complexity of **O(2n)** (basically O(n log n)), which is not cool.

If I look at the array, I can sort it regardless of the sign using one loop and just return the square of that array again (still O(2n)).  
Ohh, I can just take the square while sorting them.

I can use two pointers `i` and `j`.  
- I will start from the left side (`i = 0`) and `j` will start from the right side (`len(nums) - 1`).  
- If `i` or `j` is less than 0, then I can take the square of those two numbers and check which one is larger.  
- If `nums[i]` is greater than `nums[j]`, then I can swap them and keep `i` as it is, and decrease `j` by one.  
- If `j` is greater than `i`, then just decrease `j` and check `nums[j]` with `nums[i]`.  
- If `i > j`, stop the loop.

After some research, instead of swapping, I can just create a **new list**.  
It will use **O(n)** extra space, but people prefer that for simplicity.

---

## Final Code

```python
class Solution(object):
    def sortedSquares(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        new = [0] * len(nums)
        right = pos = len(nums) - 1
        left = 0
        
        while left <= right:
            if abs(nums[left]) > abs(nums[right]):
                new[pos] = nums[left] ** 2
                left += 1
            else:
                new[pos] = nums[right] ** 2
                right -= 1
            pos -= 1     

        return new
````

---

### Complexity

* **Time Complexity:** O(n)
* **Space Complexity:** O(n)


