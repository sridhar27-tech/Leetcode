# 167. Two Sum II – Input Array Is Sorted

## Overview

You’re given a **sorted** array and a target. You need to find **two distinct indices** (1-indexed) such that their values sum to the target. The twist is that you **must use constant extra space**, meaning no hash maps or fancy storage tricks.

This problem is basically a playground for the **two-pointer technique**, which shines the moment you see “sorted array.”

---

## Why the Two-Pointer Approach Works

Your array is in **non-decreasing order**. That means as you move right, numbers get bigger, and as you move left, numbers get smaller. That structure lets you make decisions without scanning everything.

The two-pointer trick is simple:

* One pointer (`i`) starts at the **left** (smallest values).
* Another pointer (`j`) starts at the **right** (largest values).

At each step:

* Add `numbers[i] + numbers[j]`.
* If the sum is **too big**, the right side is the problem → move `j` left.
* If the sum is **too small**, the left side is too weak → move `i` right.
* If it matches the target → you’re done.

You’re basically squeezing the array inward until the math clicks.

This works **only because the array is sorted**. Without sorting, the pointer movements would be completely blind.

---

## Step-by-Step Behavior (Not “steps”—behaviors)

1. Left pointer tries to increase the sum.
2. Right pointer tries to decrease the sum.
3. Both move **with intent**, not guesswork.
4. Eventually the two behaviors meet at exactly the needed pair.

This is why two-pointer solutions feel elegant—they don’t brute force; they adjust based on feedback.

---

## Time and Space

* **Time:** O(n) — pointers only move inward once.
* **Space:** O(1) — no extra storage.

---

## Your Code (Good and Clean)

```python
class Solution(object):
    def twoSum(self, numbers, target):
        """
        :type numbers: List[int]
        :type target: int
        :rtype: List[int]
        """
        i = 0
        j = len(numbers) - 1
        
        while i < j:
            current_sum = numbers[i] + numbers[j]
            
            if current_sum == target:
                return [i + 1, j + 1]  # 1-indexed
            elif current_sum > target:
                j -= 1  # Sum too large, move right pointer left
            else:
                i += 1  # Sum too small, move left pointer right
        
        return []
```

---

## Final Thought

The moment you see “sorted” and “pair sum,” your brain should fire off a two-pointer alert. This technique is a cornerstone for tons of array problems, and mastering it will save you from writing messy, slow solutions.

Use it wisely. Be humble about what you know and cautious about jumping into brute force whenever you get stuck—patterns like this exist to save you time.
