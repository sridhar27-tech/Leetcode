# 739. Daily Temperatures

**Difficulty:** Medium  
**Topic:** Monotonic Stack  

---

## Problem Summary

You are given an array `temperatures` where `temperatures[i]` is the temperature on day `i`.

For each day, you need to find **how many days you must wait** until a **warmer temperature** occurs.

- If no warmer day exists in the future → answer is `0`.

---

## Key Insight

This is a **Next Greater Element** problem.

For each index `i`, you want the **next index `j > i`** such that:
```

temperatures[j] > temperatures[i]

```

Brute force would be `O(n²)` — slow and lazy thinking.  
We want `O(n)`.

---

## Core Concept: Monotonic Stack

We use a **monotonic decreasing stack** (stack stores indices, not values).

### Why indices?
Because the answer is:
```

j - i

````

### Stack invariant
- Stack keeps indices of days with **strictly higher temperatures** than the current day.
- From top → bottom, temperatures are **increasing**.

---

## Strategy

We traverse **from right to left**.

Why?
- Future days are already processed.
- The stack always represents valid future candidates.

---

## Algorithm Flow

1. Initialize:
   - `res[]` array filled with `0`
   - Empty stack

2. Traverse from `n - 1` to `0`:
   - While stack is not empty **and**
     ```
     temperatures[i] >= temperatures[stack.peek()]
     ```
     → pop (those days are useless)

   - If stack is not empty:
     ```
     res[i] = stack.peek() - i
     ```

   - Push `i` onto stack

3. Return `res`

---

## Step-by-Step Example

### Input
````

temperatures = [73,74,75,71,69,72,76,73]

```

### Process (from right → left)

| i | temp | stack (top → bottom) | result |
|---|------|----------------------|--------|
| 7 | 73 | [] | 0 |
| 6 | 76 | [7] → pop | 0 |
| 5 | 72 | [6] | 1 |
| 4 | 69 | [5,6] | 1 |
| 3 | 71 | [5,6] | 2 |
| 2 | 75 | [6] | 4 |
| 1 | 74 | [2,6] | 1 |
| 0 | 73 | [1,2,6] | 1 |

### Output
```

[1,1,4,2,1,1,0,0]

````

---

## Time & Space Complexity

- **Time:** `O(n)`  
  Each index is pushed and popped **once**.

- **Space:** `O(n)`  
  Stack + result array.

---

## Java Solution

```java
class Solution {
    public int[] dailyTemperatures(int[] temp) {
        int n = temp.length;
        int[] res = new int[n];
        Stack<Integer> stack = new Stack<>();

        for (int i = n - 1; i >= 0; i--) {
            while (!stack.isEmpty() && temp[i] >= temp[stack.peek()]) {
                stack.pop();
            }

            if (!stack.isEmpty()) {
                res[i] = stack.peek() - i;
            }

            stack.push(i);
        }
        return res;
    }
}
````

---

## JavaScript Solution

```javascript
var dailyTemperatures = function(temperatures) {
    const n = temperatures.length;
    const res = new Array(n).fill(0);
    const stack = [];

    for (let i = n - 1; i >= 0; i--) {
        while (stack.length && temperatures[i] >= temperatures[stack[stack.length - 1]]) {
            stack.pop();
        }

        if (stack.length) {
            res[i] = stack[stack.length - 1] - i;
        }

        stack.push(i);
    }

    return res;
};
```

---

## Common Mistakes (Don’t Be That Person)

* Storing **values instead of indices**
* Traversing left to right and fighting the problem
* Forgetting why `>=` is used (equal temps are useless)
* Not understanding the stack invariant

If you don’t **see** why popping works, you don’t understand the solution yet. Re-read the invariant.

---

## Pattern Recognition

This exact logic appears in:

* Next Greater Element
* Stock Span
* Largest Rectangle in Histogram
* Trapping Rain Water (variant)

Learn this once properly or keep suffering forever.




