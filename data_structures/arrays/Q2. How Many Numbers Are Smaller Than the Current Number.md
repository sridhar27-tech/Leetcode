# Problem — Set Mismatch (LeetCode)

## Problem statement

You have a set of integers `s` which originally contains all the numbers from `1` to `n`. Unfortunately, due to an error, one of the numbers in `s` got duplicated to another number in the set, which results in one number appearing twice and one number missing.

You're given an integer array `nums` of length `n` representing the set after the error. Find the number that occurs twice and the number that is missing, and return them in the form `[duplicate, missing]`.

### Examples

```
Input:  nums = [1,2,2,4]
Output: [2,3]

Input:  nums = [1,1]
Output: [1,2]
```

---

## Key observations

1. `nums` length is `n`. The original set was `{1, 2, ..., n}`.
2. Exactly one value in `nums` appears twice (call it `dup`) and exactly one value from `1..n` is missing (call it `miss`).
3. Useful invariants:

   * Sum of 1..n: `S = n*(n+1)/2`.
   * Sum of squares 1..n: `SQ = n*(n+1)*(2n+1)/6`.

If we let `A = sum(nums)` and `B = sum(x*x for x in nums)`, then:

```
A = S + dup - miss
B = SQ + dup^2 - miss^2
```

From these two equations we can solve for `dup` and `miss` (see "Math (sum and sum of squares) approach").

---

## Approaches

I'll show several approaches: simple-to-understand ones first, then more optimal/clever ones.

### 1) Sort + sum (simple, easy to implement)

**Idea:** Sort the array. While scanning, detect the duplicate by comparing adjacent elements. Compute the missing number using the expected sum.

**Code (Python):**

```python
class Solution(object):
    def findErrorNums(self, nums):
        nums.sort()
        dup = -1
        for i in range(len(nums) - 1):
            if nums[i] == nums[i+1]:
                dup = nums[i]
                break

        n = len(nums)
        expected = n * (n + 1) // 2
        actual = sum(nums)
        missing = expected - (actual - dup)
        return [dup, missing]
```

**Complexity:**

* Time: `O(n log n)` because of the sort.
* Space: `O(1)` extra (if you ignore the sort's internal memory); or `O(n)` if the sort implementation needs it.

**Pros:** Simple and safe. Easy to reason about.
**Cons:** Sorting is slower than necessary (can do `O(n)` solutions).

---

### 2) Frequency / Counting array (linear time, linear space)

**Idea:** Use an auxiliary array `count` of size `n+1` (indices `1..n`) to track occurrences. The index with count `2` is `dup`; the index with count `0` is `miss`.

**Code:**

```python
class Solution(object):
    def findErrorNums(self, nums):
        n = len(nums)
        count = [0] * (n + 1)
        dup = -1
        miss = -1

        for x in nums:
            count[x] += 1
            if count[x] == 2:
                dup = x

        for i in range(1, n + 1):
            if count[i] == 0:
                miss = i
                break

        return [dup, miss]
```

**Complexity:**

* Time: `O(n)`
* Space: `O(n)`

**Pros:** Straightforward, fast.
**Cons:** Uses `O(n)` extra space.

---

### 3) In-place marking (linear time, constant extra space)

**Idea:** Iterate the array and for each number `x`, flip the sign of `nums[abs(x)-1]`. If you see a number whose target position is already negative, that number is the duplicate. After this pass, the index with a positive value indicates the missing number.

**Notes:** This modifies the input array. If modifying input is disallowed, do not use this.

**Code:**

```python
class Solution(object):
    def findErrorNums(self, nums):
        dup = -1
        n = len(nums)

        for x in nums:
            idx = abs(x) - 1
            if nums[idx] < 0:
                dup = abs(x)
            else:
                nums[idx] = -nums[idx]

        miss = -1
        for i in range(n):
            if nums[i] > 0:
                miss = i + 1
                break

        # optional: restore array by taking abs if caller cares
        return [dup, miss]
```

**Complexity:**

* Time: `O(n)`
* Space: `O(1)` extra (not counting input)

**Pros:** `O(n)` time and `O(1)` extra space.
**Cons:** Destroys input array (unless you restore it afterward).

---

### 4) Math approach: Sums and sums of squares (linear time, constant space)

**Idea:** Use the two invariants (sum and sum of squares) to form two equations and solve for `dup` and `miss`.

Let `S = sum(1..n)`, `A = sum(nums)` → `A = S + dup - miss`  → (1)
Let `SQ = sum_squares(1..n)`, `B = sum(x^2 for x in nums)` → `B = SQ + dup^2 - miss^2` → (2)

From (1): `d = dup - miss = A - S`  (call this `D`)
From (2): `d2 = dup^2 - miss^2 = B - SQ = (dup - miss)*(dup + miss) = D * (dup + miss)`

So `dup + miss = (B - SQ) / D`  (call this `Ssum`)

Finally:

```
dup = (D + Ssum) / 2
miss = Ssum - dup
```

**Careful:** `D` should never be zero for valid input (there is guaranteed to be one duplicate and one missing), but in robust code you may want to check it.

**Code:**

```python
class Solution(object):
    def findErrorNums(self, nums):
        n = len(nums)
        S = n * (n + 1) // 2
        SQ = n * (n + 1) * (2 * n + 1) // 6

        A = sum(nums)
        B = sum(x*x for x in nums)

        D = A - S  # dup - miss
        D2 = B - SQ  # dup^2 - miss^2

        # dup + miss = D2 / D
        Ssum = D2 // D

        dup = (D + Ssum) // 2
        miss = Ssum - dup

        return [dup, miss]
```

**Complexity:**

* Time: `O(n)`
* Space: `O(1)`

**Pros:** `O(n)` time and `O(1)` space without modifying input.
**Cons:** Uses arithmetic that could overflow in languages with fixed-width integers (not a problem in Python). Slightly more algebra to understand.

---

## Edge cases & gotchas

* Off-by-one in loops: iterating to `len(nums)` and accessing `nums[i+1]` will cause an index error. When comparing adjacent elements after sort, iterate `0..len(nums)-2` (i.e., `for i in range(len(nums)-1)`).
* Don’t assume the missing number equals `dup + 1`. Missing could be anywhere.
* If you use the in-place marking approach, remember it mutates `nums`. Restore if needed.
* Carefully check integer division vs float division when translating solutions to other languages.

---

## Complexity comparison summary

* Sorting + sum: Time `O(n log n)`, Space `O(1)` (or `O(n)` depending on sort). Simple.
* Counting array: Time `O(n)`, Space `O(n)`. Simple and fast.
* In-place marking: Time `O(n)`, Space `O(1)`, modifies input.
* Math (sum & sum of squares): Time `O(n)`, Space `O(1)`, no input modification. Elegant but algebra-heavy.

---

## Common mistakes (and how to avoid them)

1. Off-by-one when accessing `nums[i+1]`. Fix: iterate to `len(nums)-1` only.
2. Typo variable names (e.g., assigning `misiing` but returning `missing`). Fix: run tests and/or use an editor with linting.
3. Assuming missing = duplicate + 1. Fix: derive missing properly (use sums or counts).
4. Forgetting that some methods modify `nums` in place.

---

## Final recommendation

If you want clarity and you don't care about `O(n log n)` vs `O(n)`, go with the sorting + sum approach — it's readable and easy to debug. If you need `O(n)` time and `O(1)` space and you can modify the input, use the in-place marking approach. If you want a pure `O(n)`/`O(1)` solution that doesn't mutate input, use the math (sum & sum of squares) approach.

---

## Quick reference — Best solution (math) in one snippet

```python
class Solution(object):
    def findErrorNums(self, nums):
        n = len(nums)
        S = n * (n + 1) // 2
        SQ = n * (n + 1) * (2 * n + 1) // 6

        A = sum(nums)
        B = sum(x*x for x in nums)

        D = A - S
        Ssum = (B - SQ) // D

        dup = (D + Ssum) // 2
        miss = Ssum - dup

        return [dup, miss]
```


